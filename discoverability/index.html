<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FAS Discoverability — Europe</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root{--bg:#0d1117;--land:#1e252c;--text:#c9d1d9;--stroke:#fff;--no:#3a3f44;--lo:#2166ac;--mid:#ffffff;--hi:#b2182b}
  html,body{margin:0;height:100%}
  body{background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Ubuntu,sans-serif}
  #wrap{position:relative;height:100%}
  #controls{position:absolute;top:12px;left:12px;z-index:10;background:rgba(0,0,0,.5);padding:.75rem 1rem;border-radius:6px;backdrop-filter:blur(6px);display:flex;gap:.6rem}
  #controls label{display:flex;flex-direction:column;font-size:.9rem}
  #controls select{background:#11161d;color:var(--text);border:1px solid #222;border-radius:4px;padding:.25rem .4rem}
  svg{position:absolute;inset:0;width:100%;height:100%}
  .country{fill:var(--land)}            /* базовый слой */
  .has-data{cursor:pointer}            /* слой с данными (цвет) */
  .has-data{stroke:var(--stroke);stroke-width:1}
  .tooltip{position:absolute;background:rgba(0,0,0,.8);padding:.6rem .8rem;border-radius:6px;pointer-events:none;opacity:0;transition:opacity .15s;font-size:.9rem;max-width:360px}
  #legend{position:absolute;bottom:16px;left:16px;background:rgba(0,0,0,.5);padding:.5rem .75rem;border-radius:6px;font-size:.85rem}
  #legend .bar{height:10px;width:240px;margin:.25rem 0;background:linear-gradient(to right,var(--lo),var(--mid),var(--hi))}
</style>
</head>
<body>
<div id="wrap">
  <div id="controls">
    <label>Engine
      <select id="engine">
        <option>Google</option>
        <option>Bing</option>
        <option>DuckDuckGo</option>
      </select>
    </label>
    <label>Scan
      <select id="scan">
        <option value="1">1</option>
        <option value="2">2</option>
      </select>
    </label>
  </div>
  <svg id="map"></svg>
  <div id="legend">
    <div><b>Discoverability (median best rank)</b></div>
    <div class="bar"></div>
    <div><span id="min">min</span> &larr; <span id="mid">median</span> &rarr; <span id="max">max</span></div>
  </div>
  <div id="tooltip" class="tooltip"></div>
</div>

<script>
(async function(){
  const DATA_URL = "discoverability_by_country.json"; // положи JSON рядом или замени URL
  const data = await fetch(DATA_URL).then(r=>r.json());
  const geo  = await d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson");

  const svg = d3.select("#map");
  const tooltip = d3.select("#tooltip");
  const engineSel = d3.select("#engine");
  const scanSel   = d3.select("#scan");
  const legendMin = d3.select("#min");
  const legendMax = d3.select("#max");
  const legendMid = d3.select("#mid");

  // --- нормализация имён стран и алиасы ---
  const token = s => String(s||"").normalize("NFKD").replace(/[\u0300-\u036f]/g,"").toUpperCase().replace(/[^A-Z]/g,"");
  const countryKeys = Object.keys(data.countries||{});
  const indexByToken = new Map(countryKeys.map(k => [token(k), k]));

  // частые несоответствия между GeoJSON и нашими ключами
  const manualAliases = new Map([
    ["CZECHREPUBLIC", "Czech Republic"],   // если JSON хранит "Czech Republic"
    ["CZECHIA", "Czech Republic"],         // если geo даёт Czechia — попробуем оба
    ["BOSNIAANDHERZEGOVINA","Bosnia and Herzegovina"],
    ["NORTHMACEDONIA","North Macedonia"],
    ["UNITEDKINGDOM","United Kingdom"],
    ["KOSOVO","Kosovo"],                   // может отсутствовать в geo, но пусть будет
    ["RUSSIANFEDERATION","Russia"],
    ["MOLDOVA","Moldova"],
    ["SERBIA","Serbia"]
  ]);

  function mapToJsonKey(geoName){
    const t = token(geoName);
    // прямое совпадение по токену
    if (indexByToken.has(t)) return indexByToken.get(t);
    // ручной алиас
    if (manualAliases.has(t)) {
      const aliasName = manualAliases.get(t);
      const at = token(aliasName);
      if (indexByToken.has(at)) return indexByToken.get(at);
    }
    // эвристика: попробуем убрать слова "AND", "THE", "OF"
    const slim = t.replace(/AND|THE|OF/g,'');
    if (indexByToken.has(slim)) return indexByToken.get(slim);
    // не нашли — вернём null
    return null;
  }

  // explode multipolygons and filter to Europe
  const features=[];
  geo.features.forEach(f=>{
    if(f.geometry.type==="MultiPolygon"){
      f.geometry.coordinates.forEach(c=>features.push({type:"Feature",properties:f.properties,geometry:{type:"Polygon",coordinates:c}}));
    }else{features.push(f);}
  });
  const europe = features.filter(f=>{
    const [lon,lat]=d3.geoCentroid(f);
    return lon>-25 && lon<45 && lat>30 && lat<72;
  });

  const width = svg.node().clientWidth, height = svg.node().clientHeight;
  const projection = d3.geoNaturalEarth1().fitSize([width,height],{type:"FeatureCollection",features:europe});
  const path = d3.geoPath(projection);

  // базовый слой — только Европа, без обводки
  svg.append("g")
    .selectAll("path").data(europe)
    .join("path").attr("d",path).attr("class","country");

  const gData = svg.append("g");

  function getNodeByCountry(geoName, engine, scan){
    const key = mapToJsonKey(geoName);
    if (!key) return null;
    const c = data.countries[key];
    return (c && c[engine] && c[engine][scan]) ? c[engine][scan] : null;
  }

  function getMedian(geoName, engine, scan){
    const n = getNodeByCountry(geoName, engine, scan);
    return n ? +n.median : null;
  }
  function getValues(geoName, engine, scan){
    const n = getNodeByCountry(geoName, engine, scan);
    return n ? n.values : null;
  }

  function computeScale(engine, scan){
    const vals=[];
    europe.forEach(f=>{
      const m = getMedian(f.properties.name, engine, scan);
      if(m!=null && isFinite(m)) vals.push(+m);
    });
    if(!vals.length){ return {color: ()=>"#fff", min:0, max:1, mid:0}; }
    const min=d3.min(vals), max=d3.max(vals), mid=(min+max)/2;
    const color=d3.scaleLinear().domain([min,mid,max]).range(["#2166ac","#ffffff","#b2182b"]).clamp(true);
    return {color,min,max,mid};
  }

  function renderMiniDist(selection, values, {width=240,height=110,bins=25}={}){
    selection.selectAll("svg").remove();
    if(!values || values.length<2) return;
    const svg=d3.select(selection.node()).append("svg").attr("width",width).attr("height",height);
    const margin={top:6,right:6,bottom:14,left:6}, w=width-margin.left-margin.right, h=height-margin.top-margin.bottom;
    const g=svg.append("g").attr("transform",`translate(${margin.left},${margin.top})`);
    const v=values.map(Number).filter(Number.isFinite);
    const x=d3.scaleLinear().domain([d3.min(v), d3.max(v)]).range([0,w]);
    const binsGen=d3.bin().domain(x.domain()).thresholds(bins);
    const b=binsGen(v);
    const y=d3.scaleLinear().domain([0,d3.max(b,d=>d.length)||1]).range([h,0]);
    g.selectAll("rect").data(b).join("rect")
      .attr("x",d=>x(d.x0)).attr("y",d=>y(d.length))
      .attr("width",d=>Math.max(1,x(d.x1)-x(d.x0)-1)).attr("height",d=>h-y(d.length))
      .attr("fill","rgba(215,57,57,0.25)");
    g.append("g").attr("transform",`translate(0,${h})`).call(d3.axisBottom(x).ticks(4)).attr("font-size",9).attr("color","rgba(255,255,255,0.6)");
  }

  function update(){
    const engine = engineSel.property("value");
    const scan   = scanSel.property("value");
    const {color,min,max,mid}=computeScale(engine,scan);
    legendMin.text(min?.toFixed(2) ?? "–");
    legendMax.text(max?.toFixed(2) ?? "–");
    legendMid.text(mid?.toFixed(2) ?? "–");

    const paths=gData.selectAll("path").data(europe, d=>d.properties.name);
    paths.join(enter=>enter.append("path").attr("d",path))
      .attr("class", d => {
        const m = getMedian(d.properties.name, engine, scan);
        return (m!=null && isFinite(m)) ? "has-data" : "no-data";
      })
      .attr("fill", d => {
        const m = getMedian(d.properties.name, engine, scan);
        return (m!=null && isFinite(m)) ? color(m) : "var(--no)";
      })
      .on("mouseenter", function(e,d){
        const vals = getValues(d.properties.name, engine, scan);
        const m = getMedian(d.properties.name, engine, scan);
        if(!vals || m==null){ tooltip.style("opacity",0); return; }
        tooltip.html(`<strong>${mapToJsonKey(d.properties.name) || d.properties.name}</strong><br>Median best rank: <b>${(+m).toFixed(2)}</b><div id="mini"></div>`).style("opacity",1);
        renderMiniDist(tooltip.select("#mini"), vals);
      })
      .on("mousemove", function(e){ tooltip.style("left",(e.clientX+12)+"px").style("top",(e.clientY+12)+"px"); })
      .on("mouseleave", function(){ tooltip.style("opacity",0); });
  }

  engineSel.on("change", update);
  scanSel.on("change", update);
  update();
})();
</script>
</body>
</html>