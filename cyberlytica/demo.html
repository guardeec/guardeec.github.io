<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Cyberlytica • Privacy Risks Explorer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
    <style>
        :root {
            --bg-main: #0f1115;
            --surface-1: #171a21;
            --surface-2: #13161b;
            --surface-3: #1e222a;
            --txt: #e6e7ea;
            --muted: #c4c9d4; /* Improved contrast for accessibility */
            --brand-1: #c43b3b;
            --brand-2: #89f7fe;
            --btn: #2b2f39;
            --btn-active: #3d6be8;
            
            /* Gradient color stops for yellow spectrum (amber) */
            --amber-light: #fbbf24;
            --amber-core: #f59e0b;
            --amber-deep: #d97706;
            --amber-glow: rgba(251, 191, 36, 0.35);
            
            /* Gradient color stops for red spectrum (coral) */
            --coral-light: #f87171;
            --coral-core: #ef4444;
            --coral-deep: #dc2626;
            --coral-crimson: #b91c1c;
            --coral-glow: rgba(239, 68, 68, 0.35);
            
            /* Neutral/safe spectrum (slate) */
            --slate-light: #94a3b8;
            --slate-core: #64748b;
            --slate-deep: #475569;
            
            /* Buttons using the new palette */
            --btn-danger: var(--coral-core);
            
            /* Risk chip colors using the new palette */
            --chip-low: var(--slate-core);
            --chip-med: var(--amber-deep);
            --chip-high: var(--coral-deep);
            
            /* Success color for toasts */
            --success: #22c55e;
            --success-glow: rgba(34, 197, 94, 0.35);
            
            /* Typography */
            --font-display: 'DM Sans', ui-sans-serif, system-ui, sans-serif;
            --font-mono: 'JetBrains Mono', ui-monospace, monospace;
        }

        * {
            box-sizing: border-box;
            font-family: var(--font-display);
        }
        
        /* ===== Focus states for accessibility ===== */
        *:focus {
            outline: none;
        }
        
        *:focus-visible {
            outline: 2px solid var(--brand-2);
            outline-offset: 2px;
            border-radius: 4px;
        }
        
        button:focus-visible,
        input:focus-visible {
            outline: 2px solid var(--brand-2);
            outline-offset: 2px;
        }

        body {
            margin: 0;
            background: var(--bg-main);
            color: var(--txt);
        }

        /* ===== Brand header ===== */
        header#brandBar {
            position: static;
            background: linear-gradient(180deg, rgba(138, 180, 255, .10), rgba(137, 247, 254, .06) 35%, rgba(0, 0, 0, 0) 100%);
        }

        .brand-inner {
            max-width: 1280px;
            margin: 0 auto;
            padding: 28px 20px 18px;
        }

        .brand-title {
            font-family: 'Russo One', system-ui;
            letter-spacing: .5px;
            font-size: 44px;
            line-height: 1;
            background: linear-gradient(90deg, var(--brand-1), var(--brand-2));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .brand-sub {
            margin-top: 6px;
            color: var(--muted);
            font-size: 13px;
        }

        /* ===== Main layout ===== */
        .main-container {
            display: flex;
            min-height: calc(100vh - 120px);
            gap: 20px;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* ===== Left panel ===== */
        .left-panel {
            flex: 0 0 400px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .search-section {
            background: var(--surface-1);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .search-wrap {
            flex: 1;
            position: relative;
        }

        .import-btn {
            padding: 14px 18px;
            border: none;
            border-radius: 12px;
            background: var(--btn-active);
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform .15s ease, box-shadow .25s ease;
            box-shadow: 0 4px 12px rgba(61, 107, 232, .3);
            white-space: nowrap;
        }

        .import-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(61, 107, 232, .4);
        }

        /* Video import overlay */
        #videoImportOverlay {
            position: fixed;
            inset: 0;
            display: none;
            place-items: center;
            background: rgba(5, 7, 10, .85);
            backdrop-filter: blur(4px);
            z-index: 1000;
        }

        #videoImportOverlay.active {
            display: grid;
        }

        .video-import-card {
            background: var(--surface-1);
            padding: 28px;
            border-radius: 20px;
            min-width: 480px;
            max-width: 90vw;
            box-shadow: 0 20px 50px rgba(0, 0, 0, .7);
        }

        .video-import-card h3 {
            margin: 0 0 20px;
            font-size: 20px;
            font-weight: 700;
        }

        .video-import-card .file-input-wrapper {
            margin-bottom: 20px;
        }

        .video-import-card input[type="file"] {
            display: none;
        }

        .video-import-card .file-label {
            display: block;
            padding: 16px;
            border: 2px dashed var(--btn);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all .2s ease;
            color: var(--txt);
        }

        .video-import-card .file-label:hover {
            border-color: var(--btn-active);
            background: rgba(61, 107, 232, .1);
        }

        .video-import-progress {
            margin-top: 20px;
            display: none;
        }

        .video-import-progress.active {
            display: block;
        }

        .video-import-progress-bar {
            width: 100%;
            height: 8px;
            background: var(--surface-2);
            border-radius: 999px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .video-import-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--btn-active), #5a67d8);
            border-radius: 999px;
            transition: width .3s ease;
            width: 0%;
        }

        .video-import-progress-text {
            font-size: 13px;
            color: var(--muted);
            text-align: center;
        }

        .video-import-help {
            margin: 8px 0 16px;
            font-size: 13px;
            color: var(--muted);
            line-height: 1.45;
        }
        .video-import-help.hidden {
            display: none;
        }

        .video-import-help strong {
            color: var(--txt);
            font-weight: 700;
        }

        .video-import-help ol {
            margin: 8px 0 0;
            padding-left: 18px;
        }

        .video-import-help li {
            margin: 6px 0;
        }

        .found-apps-strip {
            margin-top: 14px;
            margin-left: auto;
            margin-right: auto;
            display: none;
            align-items: center;
            justify-content: center;
            width: 100%;
            overflow: hidden;
        }

        .found-apps-strip.active {
            display: flex;
        }

        .found-apps-track {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: -10px; /* compensate for last icon's margin */
        }

        .found-apps-strip .app-icon-bubble {
            width: 44px;
            height: 44px;
            margin-right: 10px;
            border-radius: 14px;
            background: #0d0e10;
            overflow: hidden;
            display: grid;
            place-items: center;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, .06) inset, 0 10px 20px rgba(0,0,0,.35);
            opacity: 1;
            transform: scale(1);
            transition: transform 0.3s ease, opacity 0.3s ease, width 0.3s ease, margin-right 0.3s ease;
            flex-shrink: 0;
            position: relative;
        }

        .found-apps-strip .app-icon-bubble.show {
            width: 44px;
            margin-right: 10px;
            transform: scale(1);
            opacity: 1;
        }

        /* New icon enters - starts collapsed, expands into place */
        .found-apps-strip .app-icon-bubble.entering {
            width: 0;
            min-width: 0;
            margin-right: 0;
            opacity: 0;
            transform: scale(0.8);
        }

        /* Old icon exits - collapses and fades */
        .found-apps-strip .app-icon-bubble.exiting {
            width: 0;
            min-width: 0;
            margin-right: 0;
            opacity: 0;
            transform: scale(0.8);
        }

        .found-apps-strip img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .found-apps-strip .spark {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 20%, rgba(137,247,254,.35), transparent 55%),
                        radial-gradient(circle at 70% 80%, rgba(61,107,232,.35), transparent 55%);
            opacity: 0;
            transform: scale(0.9);
            transition: opacity .22s, transform .22s;
            pointer-events: none;
        }

        .found-apps-strip .app-icon-bubble.pulse .spark {
            opacity: 1;
            transform: scale(1);
        }

        .video-import-close {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 8px;
            background: var(--surface-2);
            color: var(--txt);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: background .2s ease;
        }

        .video-import-close:hover {
            background: var(--btn);
        }

        .video-import-card {
            position: relative;
        }

        .search-wrap {
            position: relative;
        }

        #searchInput {
            width: 100%;
            padding: 14px 16px;
            border: none;
            outline: none;
            border-radius: 14px;
            background: var(--surface-2);
            color: var(--txt);
            font-size: 15px;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, .06) inset, 0 10px 30px rgba(0, 0, 0, .35);
        }

        #suggestions {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            right: 0;
            background: var(--surface-1);
            border: none;
            border-radius: 14px;
            box-shadow: 0 18px 44px rgba(0, 0, 0, .55);
            max-height: 360px;
            overflow: auto;
            display: none;
            z-index: 55;
        }

        .sugg-item {
            padding: 11px 14px;
            display: flex;
            justify-content: space-between;
            gap: 12px;
            cursor: pointer;
        }

        .sugg-item:hover {
            background: #1b2029;
        }

        .sugg-name {
            font-size: 14px;
        }

        .sugg-id {
            font-size: 12px;
            opacity: .7;
        }

        .analyze-section {
            display: none !important;
            background: var(--surface-1);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
            transition: all .4s ease;
            overflow: hidden;
        }

        .analyze-section.hidden {
            max-height: 0;
            padding: 0 16px;
            margin: 0;
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }

        .analyze-section.visible {
            max-height: 100px;
            padding: 16px;
            margin: 0;
            opacity: 1;
            transform: scale(1);
        }

        .analyze-btn {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--btn-active), #5a67d8);
            color: #fff;
            cursor: not-allowed;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(61, 107, 232, .3);
            opacity: .6;
        }

        .analyze-icon {
            font-size: 20px;
        }

        .analyze-text {
            flex: 1;
        }

        .app-list-section {
            flex: 1;
            background: var(--surface-1);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .app-list-header {
            font-weight: 700;
            font-size: 16px;
            margin-bottom: 12px;
            color: var(--txt);
        }

        .app-list {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .app-list-item {
            background: var(--surface-2);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all .2s ease;
            border: 2px solid transparent;
        }

        .app-list-item:hover {
            background: #1b2029;
            transform: translateY(-2px);
        }

        .app-list-item.selected {
            border-color: var(--btn-active);
            background: #1b2029;
        }

        .app-list-item-content {
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .app-list-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            flex: 0 0 48px;
            background: #0d0e10;
            overflow: hidden;
            display: grid;
            place-items: center;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, .05) inset;
        }

        .app-list-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .app-list-meta {
            flex: 1;
            min-width: 0;
        }

        .app-list-name {
            font-weight: 600;
            font-size: 14px;
            margin: 0 0 4px;
        }

        .app-list-desc {
            font-size: 12px;
            opacity: .8;
            margin: 0 0 6px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .app-list-id {
            font-size: 11px;
            color: var(--muted);
        }

        .app-list-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .btn-delete {
            padding: 4px 8px;
            border: none;
            border-radius: 6px;
            background: var(--btn-danger);
            color: #fff;
            font-size: 11px;
            cursor: pointer;
            transition: all .2s ease;
        }

        .btn-delete:hover {
            background: #c62828;
            transform: scale(1.05);
        }

        /* ===== Right panel ===== */
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
            min-width: 0; /* <-- это ключевая строчка */
        }

        .app-details-section {
            background: var(--surface-1);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
        }

        /* ===== Risk panel ===== */
        .risk-panel-section {
            background: var(--surface-1);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .risk-panel-header {
            font-size: 14px;
            font-weight: 600;
            color: var(--muted);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .risk-panel-inner {
            display: flex;
            gap: 16px;
            align-items: stretch;
        }

        .risk-gauge-container {
            flex: 0 0 33%;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .risk-gauge-title {
            font-size: 13px;
            color: var(--muted);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .risk-gauge-svg {
            width: 220px;
            height: 220px;
        }

        .risk-gauge-value {
            margin-top: 6px;
            font-size: 14px;
            color: var(--muted);
        }

        .risk-radar-container {
            flex: 1 1 auto;
            min-width: 260px;
            position: relative;
        }

        .risk-radar-title {
            font-size: 13px;
            color: var(--muted);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .risk-radar-svg {
            width: 100%;
            max-width: 520px;
            height: 260px;
            display: block;
            margin: 0 auto;
        }

        .risk-legend {
            position: absolute;
            right: 0;
            top: 0;
            font-size: 11px;
            color: var(--muted);
            display: flex;
            flex-wrap: wrap;
            gap: 4px 10px;
            max-width: 260px;
        }

        .risk-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .risk-legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 999px;
            background: #9ca3af;
        }

        .risk-legend-dot-risk {
            /* цвет совпадает с полигоном риска - gradient effect */
            background: linear-gradient(135deg, var(--amber-light), var(--coral-core));
        }

        .risk-legend-dot-grid {
            background: #4b5563;
        }

        .risk-panel-empty {
            font-size: 13px;
            color: var(--muted);
        }

        @media (max-width: 1024px) {
            .risk-panel-inner {
                flex-direction: column;
            }

            .risk-gauge-container {
                flex: 0 0 auto;
                align-items: center;
            }

            .risk-radar-container {
                min-height: 260px;
            }
        }

        .app-header {
            display: none;
            transform: translateY(0);
            opacity: 1;
            transition: opacity 0.18s cubic-bezier(0.22, 0.61, 0.36, 1),
            transform 0.18s cubic-bezier(0.22, 0.61, 0.36, 1);
        }

        .app-header.no-transition {
            transition: none !important;
        }

        /* меньшее смещение, чтобы глаз не цеплялся */
        .app-header.from-top {
            transform: translateY(-6px);
            opacity: 0;
        }

        .app-row {
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }

        .app-icon {
            width: 92px;
            height: 92px;
            border-radius: 22px;
            flex: 0 0 92px;
            background: #0d0e10;
            overflow: hidden;
            display: grid;
            place-items: center;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, .05) inset;
        }

        .app-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .app-meta {
            flex: 1 1 auto;
            min-width: 0;
        }

        .app-name {
            font-weight: 800;
            font-size: 22px;
            margin: 0 0 8px;
            letter-spacing: .2px;
        }

        .app-desc {
            font-size: 15px;
            opacity: .92;
            margin: 0 0 10px;
            display: -webkit-box;
            -webkit-line-clamp: 8;
            line-clamp: 8;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .app-extra {
            font-size: 12px;
            color: var(--muted);
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .app-score {
            margin-top: 6px;
            font-size: 13px;
            color: var(--muted);
        }

        .app-footer-row {
            margin-top: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .view-toggle {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            padding: 2px;
            border-radius: 999px;
            background: var(--surface-2);
            box-shadow: 0 0 0 1px rgba(255, 255, 255, .05) inset;
        }

        .view-toggle-btn {
            border: none;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: .08em;
            background: transparent;
            color: var(--muted);
            cursor: pointer;
            transition: background .18s, color .18s, box-shadow .18s, transform .12s;
        }

        .view-toggle-btn:hover {
            transform: translateY(-1px);
        }

        .view-toggle-btn.active {
            background: var(--btn-active);
            color: #fff;
            box-shadow: 0 4px 12px rgba(61, 107, 232, .4);
        }

        /* Общие классы для анимации переключения Dashboard / JSON */
        .view-panel {
            transition: opacity 0.18s cubic-bezier(0.22, 0.61, 0.36, 1),
            transform 0.18s cubic-bezier(0.22, 0.61, 0.36, 1);
        }

        .visible-view {
            opacity: 1;
            transform: translateY(0);
        }

        .hidden-view {
            opacity: 0;
            transform: translateY(8px);
            pointer-events: none;
            height: 0;
            margin-top: 0;
            margin-bottom: 0;
            overflow: hidden;
        }

        /* JSON-панель */
        .json-section {
            background: var(--surface-1);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
            display: flex;
            flex-direction: column;
            min-height: 220px;
            min-width: 0; /* чтобы не раздвигала правую колонку */
        }

        .json-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
            color: var(--muted);
        }

        #copyJsonBtn {
            padding: 6px 10px;
            border-radius: 10px;
            border: none;
            background: var(--btn);
            color: var(--txt);
            font-size: 12px;
            cursor: pointer;
            box-shadow: 0 1px 0 rgba(255, 255, 255, .05) inset, 0 6px 18px rgba(0, 0, 0, .35);
            transition: background .18s, transform .12s, box-shadow .18s;
        }

        #copyJsonBtn:hover {
            transform: translateY(-1px);
        }

        #copyJsonBtn.copied {
            background: var(--btn-active);
            box-shadow: 0 8px 20px rgba(61, 107, 232, .4);
        }

        .json-code {
            flex: 1;
            margin-top: 6px;
            background: var(--surface-2);
            border-radius: 12px;
            padding: 12px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre; /* не переносим строки */
            max-width: 100%; /* не даём блоку стать шире контейнера */
            overflow-x: auto; /* горизонтальный скролл */
            overflow-y: auto;
        }

        /* Простенький синтакс-хайлайт JSON */
        .json-key {
            color: #93c5fd; /* голубой */
        }

        .json-string {
            color: #6ee7b7; /* мятный */
        }

        .json-number {
            color: #fbbf24; /* жёлтый */
        }

        .json-boolean {
            color: #f97373; /* красный */
        }

        .json-null {
            color: #9ca3af; /* серый */
        }

        .controls-section {
            background: var(--surface-1);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
        }

        #controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        #controls button {
            padding: 8px 12px;
            border: none;
            border-radius: 10px;
            background: var(--btn);
            color: var(--txt);
            font-size: 13px;
            cursor: pointer;
            transition: transform .15s ease, background .25s ease, box-shadow .25s ease;
            box-shadow: 0 1px 0 rgba(255, 255, 255, .05) inset, 0 6px 18px rgba(0, 0, 0, .35);
            white-space: nowrap;
        }

        #controls button:hover {
            transform: translateY(-1px);
        }

        #controls button.active {
            background: var(--btn-active);
            color: #fff;
            box-shadow: 0 10px 24px rgba(61, 107, 232, .35);
        }

        .viz-section {
            flex: 1;
            background: var(--surface-1);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #groups {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            display: grid;
            gap: 16px;
            align-content: flex-start;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));

            transform: translateX(0) translateY(0);
            opacity: 1;
            transition: opacity 0.18s cubic-bezier(0.22, 0.61, 0.36, 1),
            transform 0.18s cubic-bezier(0.22, 0.61, 0.36, 1);
        }

        #groups.no-transition {
            transition: none !important;
        }

        /* горизонтальные эффекты оставляем как были */
        #groups.from-right {
            transform: translateX(40px);
            opacity: 0;
        }

        #groups.from-left {
            transform: translateX(-40px);
            opacity: 0;
        }

        /* вертикальный свайп при смене приложения – делаем мягче */
        #groups.from-top {
            transform: translateY(-8px);
            opacity: 0;
        }

        .group {
            background: var(--surface-2);
            border-radius: 12px;
            padding: 14px 14px 12px;
            /* убираем flex и ручные max/min width */
            box-shadow: 0 0 0 1px rgba(255, 255, 255, .04);
        }

        .group-title {
            font-weight: 700;
            margin-bottom: 10px;
            font-size: 15px;
        }

        .group-subtitle {
            font-weight: 500;
            margin-top: 6px;
            margin-bottom: 4px;
            font-size: 12px;
            color: var(--muted);
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .chip {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 999px;
            font-size: 11px;
            line-height: 1.2;
            white-space: nowrap;
            color: #fff;
            letter-spacing: .02em;
            transition: transform .25s, filter .25s, box-shadow .25s;
            cursor: default;
            position: relative;
            max-width: 100%;
            text-overflow: ellipsis;
            overflow: hidden;
        }

        .chip:hover {
            transform: translateY(-3px) scale(1.06);
            box-shadow: 0 4px 10px rgba(0, 0, 0, .6);
            filter: brightness(1.12);
        }

        /* для DataCollected: два основных состояния */
        .chip-present { /* Present = data is collected - coral gradient */
            background: linear-gradient(135deg, var(--coral-light), var(--coral-deep));
            box-shadow: 0 0 0 1px rgba(0, 0, 0, .15) inset, 0 2px 10px var(--coral-glow);
        }

        .chip-partial { /* Partial = серый */
            background: linear-gradient(135deg, var(--slate-light), var(--slate-deep));
            box-shadow: 0 0 0 1px rgba(0, 0, 0, .15) inset;
        }

        /* запасной вариант для текстовых/прочих значений (если вдруг где-то пригодится) */
        .chip-text {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            box-shadow: 0 0 0 1px rgba(0, 0, 0, .12) inset;
        }

        /* риск-чипы по бэндам - modern gradients */
        .chip-low {
            background: linear-gradient(135deg, var(--slate-light), var(--slate-deep));
            box-shadow: 0 0 0 1px rgba(0, 0, 0, .2) inset, 0 2px 8px rgba(100, 116, 139, 0.25);
        }

        .chip-med {
            background: linear-gradient(135deg, var(--amber-light), var(--amber-deep));
            box-shadow: 0 0 0 1px rgba(0, 0, 0, .15) inset, 0 2px 12px var(--amber-glow);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .chip-high {
            background: linear-gradient(135deg, var(--coral-light), var(--coral-crimson));
            box-shadow: 0 0 0 1px rgba(0, 0, 0, .15) inset, 0 2px 12px var(--coral-glow);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Табличка для шаринга */
        .sharing-table {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 4px;
            font-size: 13px;
        }

        .sharing-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            border-radius: 8px;
            background: #111318;
        }

        .sharing-label {
            color: var(--txt);
        }

        .sharing-status {
            font-size: 16px;
        }

        .sharing-status-yes {
            color: #22c55e;
        }

        .sharing-status-no {
            color: #ef4444;
        }

        .group-risk-low {
            box-shadow: 0 0 0 2px var(--slate-core) inset, 0 10px 24px rgba(0, 0, 0, .35);
        }

        .group-risk-med {
            box-shadow: 0 0 0 2px var(--amber-core) inset, 0 10px 24px rgba(0, 0, 0, .35), 0 0 20px var(--amber-glow);
        }

        .group-risk-high {
            box-shadow: 0 0 0 2px var(--coral-core) inset, 0 10px 24px rgba(0, 0, 0, .35), 0 0 24px var(--coral-glow);
        }

        .group-border-strong {
            box-shadow: 0 0 0 2px var(--coral-core) inset, 0 10px 24px rgba(0, 0, 0, .35), 0 0 24px var(--coral-glow);
        }


        .group-border-weak {
            box-shadow: 0 0 0 2px var(--slate-core) inset;
        }

        .group-border-med {
            box-shadow: 0 0 0 2px var(--amber-core) inset, 0 0 16px var(--amber-glow);
        }

        .group-border-high {
            box-shadow: 0 0 0 2px var(--coral-core) inset, 0 0 16px var(--coral-glow);
        }

        .group-border-low {
            box-shadow: 0 0 0 2px var(--slate-core) inset, 0 10px 24px rgba(0, 0, 0, .35);
        }

        .group-border-med {
            box-shadow: 0 0 0 2px var(--amber-core) inset, 0 10px 24px rgba(0, 0, 0, .35), 0 0 20px var(--amber-glow);
        }

        .group-border-high {
            box-shadow: 0 0 0 2px var(--coral-core) inset, 0 10px 24px rgba(0, 0, 0, .35), 0 0 24px var(--coral-glow);
        }

        /* Tooltip */
        #tooltip {
            position: fixed;
            max-width: 320px;
            padding: 10px 12px;
            font-size: 12px;
            border-radius: 8px;
            background: #2b2f39;
            color: #fff;
            pointer-events: none;
            opacity: 0;
            transition: opacity .15s ease;
            z-index: 100;
            box-shadow: 0 10px 24px rgba(0, 0, 0, .55);
        }

        #riskPanelMeta {
            display: none !important;
        }

        /* Empty state */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            color: var(--muted);
            text-align: center;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: .5;
        }

        .empty-state-text {
            font-size: 16px;
            margin-bottom: 8px;
        }

        .empty-state-subtext {
            font-size: 14px;
            opacity: .7;
        }

        /* Gate */
        #gate {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(5, 7, 10, .6);
            backdrop-filter: blur(3px);
            z-index: 999;
        }

        #gateCard {
            background: var(--surface-1);
            padding: 22px;
            border-radius: 16px;
            min-width: 320px;
            box-shadow: 0 18px 44px rgba(0, 0, 0, .6);
        }

        #gateCard h3 {
            margin: 0 0 12px;
        }

        #gateForm input {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 10px;
            background: var(--surface-2);
            color: var(--txt);
            margin-bottom: 12px;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, .06) inset;
        }

        #gateBtn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 10px;
            background: var(--btn-active);
            color: #fff;
            cursor: pointer;
        }

        #gateErr {
            color: var(--coral-core);
            margin-top: 10px;
            font-size: 12px;
            min-height: 16px;
        }

        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }

            .left-panel {
                flex: 0 0 auto;
            }

            .group {
                max-width: calc(100% - 8px);
            }
        }

        @media (max-width: 700px) {
            .brand-title {
                font-size: 34px
            }

            .main-container {
                padding: 10px;
                gap: 12px;
            }

            .left-panel {
                flex: 0 0 auto;
            }

            .group {
                min-width: 250px;
            }
        }

        #groups {
            grid-auto-flow: row dense;
        }

        /* ===== Top View Switcher ===== */
        .top-switcher {
            display: flex;
            justify-content: center;
            gap: 4px;
            padding: 4px;
            background: var(--surface-2);
            border-radius: 14px;
            width: fit-content;
        }

        .top-switcher-btn {
            padding: 10px 28px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all .2s ease;
            background: transparent;
            color: var(--muted);
        }

        .top-switcher-btn:hover {
            color: var(--txt);
        }

        .top-switcher-btn.active {
            background: var(--btn-active);
            color: #fff;
            box-shadow: 0 4px 14px rgba(61, 107, 232, .35);
        }
        
        /* ===== Settings Button ===== */
        .settings-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            background: var(--surface-2);
            color: var(--txt);
            box-shadow: 0 0 0 1px rgba(255,255,255,0.1) inset, 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        
        .settings-btn:hover {
            transform: translateY(-1px);
            background: var(--surface-3);
            box-shadow: 0 0 0 1px rgba(255,255,255,0.15) inset, 0 6px 16px rgba(0,0,0,0.4);
        }
        
        .settings-btn:active {
            transform: translateY(0);
        }
        
        /* ===== Settings Modal ===== */
        .settings-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(5, 7, 10, 0.85);
            backdrop-filter: blur(8px);
            z-index: 1002;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        .settings-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .settings-modal {
            background: linear-gradient(145deg, var(--surface-1), var(--surface-2));
            border-radius: 24px;
            padding: 0;
            width: 90%;
            max-width: 520px;
            max-height: 85vh;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.7),
                        0 0 0 1px rgba(255,255,255,0.08) inset;
            transform: scale(0.9) translateY(20px);
            transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .settings-modal-overlay.active .settings-modal {
            transform: scale(1) translateY(0);
        }
        
        .settings-modal-header {
            padding: 24px 24px 16px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .settings-modal-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--txt);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .settings-modal-close {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 10px;
            background: var(--surface-2);
            color: var(--muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: background 0.2s, color 0.2s, transform 0.15s;
        }
        
        .settings-modal-close:hover {
            background: var(--btn);
            color: var(--txt);
            transform: scale(1.05);
        }
        
        .settings-modal-body {
            padding: 20px 24px 24px;
            overflow-y: auto;
            flex: 1;
        }
        
        .settings-section {
            margin-bottom: 24px;
        }
        
        .settings-section:last-child {
            margin-bottom: 0;
        }
        
        .settings-section-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .settings-section-content {
            background: var(--surface-2);
            border-radius: 14px;
            padding: 16px;
        }
        
        .settings-user-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .settings-user-email {
            font-size: 14px;
            color: var(--txt);
            word-break: break-all;
        }
        
        .settings-logout-btn {
            padding: 8px 14px;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(135deg, var(--coral-light), var(--coral-crimson));
            color: #fff;
            box-shadow: 0 2px 8px var(--coral-glow);
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        
        .settings-logout-btn:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }
        
        .settings-instructions {
            font-size: 13px;
            color: var(--txt);
            line-height: 1.6;
        }
        
        .settings-instructions p {
            margin: 0 0 10px;
        }
        
        .settings-instructions p:last-child {
            margin-bottom: 0;
        }
        
        .settings-kbd {
            display: inline-block;
            padding: 2px 8px;
            background: var(--surface-1);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--brand-2);
            margin: 0 2px;
        }
        
        .settings-step {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .settings-step:last-child {
            margin-bottom: 0;
        }
        
        .settings-step-num {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--btn-active);
            color: #fff;
            font-size: 12px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .settings-step-text {
            flex: 1;
            font-size: 13px;
            color: var(--txt);
            line-height: 1.5;
        }
        
        .settings-footer {
            padding: 16px 24px;
            border-top: 1px solid rgba(255,255,255,0.06);
            text-align: center;
            font-size: 12px;
            color: var(--muted);
        }
        
        .settings-footer a {
            color: var(--brand-2);
            text-decoration: none;
        }
        
        .settings-footer a:hover {
            text-decoration: underline;
        }

        /* ===== Right Panel View Switching ===== */
        .right-view {
            display: none;
            flex-direction: column;
            gap: 16px;
            flex: 1;
            opacity: 1;
            transform: translateX(0);
            transition: opacity 0.25s ease, transform 0.25s ease;
        }

        .right-view.active {
            display: flex;
        }
        
        .right-view.view-enter-right {
            opacity: 0;
            transform: translateX(30px);
        }
        
        .right-view.view-enter-left {
            opacity: 0;
            transform: translateX(-30px);
        }
        
        .right-view.view-exit-right {
            opacity: 0;
            transform: translateX(30px);
        }
        
        .right-view.view-exit-left {
            opacity: 0;
            transform: translateX(-30px);
        }

        /* Dashboard and MyApps right view specific styles can be added here */

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 200px);
            gap: 16px;
            width: 100%;
        }

        .widget {
            background: var(--surface-1);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0; /* Important for flex children to respect overflow */
        }

        .widget-2x2 {
            grid-column: span 2;
            grid-row: span 2;
        }

        .widget-1x1 {
            grid-column: span 1;
            grid-row: span 1;
        }

        .widget-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0; /* Allow content to shrink */
            overflow: hidden;
        }

        .widget-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        /* Circle Packing Widget - Modern Design */
        .circle-packing-svg {
            width: 100%;
            height: 100%;
        }

        .circle-packing-svg .category-group {
            cursor: pointer;
        }

        .circle-packing-svg .category-group {
            cursor: pointer;
        }

        .circle-packing-svg .hit-area {
            fill: transparent;
            stroke: none;
        }


        .circle-packing-svg .category-circle {
            stroke: rgba(255,255,255,0.2);
            stroke-width: 2;
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.4));
            transition: filter 0.3s ease, stroke 0.2s ease;
        }

        .circle-packing-svg .category-group:hover .category-circle {
            filter: drop-shadow(0 8px 28px rgba(0,0,0,0.7)) brightness(1.15);
            stroke: rgba(255,255,255,0.5);
        }

        .circle-packing-svg .category-label {
            font-weight: 600;
            fill: #fff;
            pointer-events: none;
            text-anchor: middle;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }

        .circle-packing-svg .category-count {
            fill: rgba(255,255,255,0.85);
            pointer-events: none;
            text-anchor: middle;
            text-shadow: 0 1px 2px rgba(0,0,0,0.7);
        }

        .circle-packing-svg .app-icons-group {
            opacity: 0;
        }

        .circle-packing-svg .app-icon-circle {
            stroke: rgba(255,255,255,0.25);
            stroke-width: 1;
        }

        .circle-packing-svg .app-icon-circle {
            stroke: rgba(255,255,255,0.3);
            stroke-width: 1;
            pointer-events: none;
        }

        .circle-packing-svg .app-icon-image {
            pointer-events: none;
        }

        /* Category Detail Modal */
        .category-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(5, 7, 10, 0.85);
            backdrop-filter: blur(8px);
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .category-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .category-modal {
            background: linear-gradient(145deg, var(--surface-1), var(--surface-2));
            border-radius: 24px;
            padding: 0;
            max-width: 480px;
            width: 90%;
            max-height: 80vh;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.7),
                        0 0 0 1px rgba(255,255,255,0.08) inset;
            transform: scale(0.9) translateY(20px);
            transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .category-modal-overlay.active .category-modal {
            transform: scale(1) translateY(0);
        }

        .category-modal-header {
            padding: 24px 24px 16px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .category-modal-icon {
            width: 56px;
            height: 56px;
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
        }

        .category-modal-title-wrap {
            flex: 1;
            min-width: 0;
        }

        .category-modal-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--txt);
            margin: 0 0 4px;
        }

        .category-modal-subtitle {
            font-size: 13px;
            color: var(--muted);
        }

        .category-modal-close {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 10px;
            background: var(--surface-2);
            color: var(--muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: background 0.2s, color 0.2s, transform 0.15s;
            flex-shrink: 0;
        }

        .category-modal-close:hover {
            background: var(--btn);
            color: var(--txt);
            transform: scale(1.05);
        }

        .category-modal-body {
            padding: 16px 24px 24px;
            overflow-y: auto;
            flex: 1;
        }

        .category-modal-apps {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .category-modal-app {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 14px;
            background: var(--surface-2);
            border-radius: 14px;
            cursor: pointer;
            transition: background 0.2s, transform 0.15s, box-shadow 0.2s;
            border: 1px solid transparent;
        }
        
        .category-modal-app .category-modal-app-arrow {
            margin-top: 8px;
        }
        
        .category-modal-app .category-modal-app-icon {
            margin-top: 2px;
        }

        .category-modal-app:hover {
            background: #1b2029;
            transform: translateX(4px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            border-color: rgba(61, 107, 232, 0.3);
        }

        .category-modal-app-icon {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            background: #0d0e10;
            overflow: hidden;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .category-modal-app-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .category-modal-app-info {
            flex: 1;
            min-width: 0;
        }

        .category-modal-app-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--txt);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .category-modal-app-score {
            font-size: 12px;
            color: var(--muted);
            margin-top: 2px;
        }

        .category-modal-app-arrow {
            color: var(--muted);
            font-size: 16px;
            opacity: 0;
            transform: translateX(-8px);
            transition: opacity 0.2s, transform 0.2s;
        }

        .category-modal-app:hover .category-modal-app-arrow {
            opacity: 1;
            transform: translateX(0);
        }

        .category-modal-risk-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
        }

        .category-modal-risk-badge.high {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.25), rgba(185, 28, 28, 0.25));
            color: var(--coral-light);
            box-shadow: 0 0 12px var(--coral-glow);
        }

        .category-modal-risk-badge.med {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.25), rgba(217, 119, 6, 0.25));
            color: var(--amber-light);
            box-shadow: 0 0 12px var(--amber-glow);
        }

        .category-modal-risk-badge.low {
            background: linear-gradient(135deg, rgba(148, 163, 184, 0.2), rgba(71, 85, 105, 0.2));
            color: var(--slate-light);
        }

        .category-modal-app-data {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .category-modal-data-chip {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 10px;
            background: rgba(255,255,255,0.08);
            color: var(--muted);
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Rose Histogram Widget */
        .rose-histogram-svg {
            width: 100%;
            height: 100%;
        }

        .rose-petal {
            cursor: pointer;
            transition: filter 0.25s ease, opacity 0.25s ease;
        }

        .rose-petal:hover {
            filter: brightness(1.4) drop-shadow(0 0 8px currentColor);
        }

        .rose-label {
            font-size: 10px;
            fill: var(--muted);
            pointer-events: none;
            transition: fill 0.2s ease;
        }

        .rose-petal-group:hover .rose-label {
            fill: var(--fg);
        }

        .rose-petal-group {
            cursor: pointer;
        }

        /* Rose Modal */
        .rose-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(8px);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
        }

        .rose-modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .rose-modal {
            background: var(--surface-1);
            border-radius: 20px;
            padding: 24px;
            min-width: 340px;
            max-width: 420px;
            max-height: 70vh;
            box-shadow: 0 25px 60px rgba(0,0,0,0.5);
            transform: scale(0.9) translateY(20px);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            flex-direction: column;
        }

        .rose-modal-overlay.active .rose-modal {
            transform: scale(1) translateY(0);
        }

        .rose-modal-header {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 18px;
        }

        .rose-modal-icon {
            width: 48px;
            height: 48px;
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
        }

        .rose-modal-titles {
            flex: 1;
        }

        .rose-modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--fg);
        }

        .rose-modal-subtitle {
            font-size: 13px;
            color: var(--muted);
            margin-top: 2px;
        }

        .rose-modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            color: var(--muted);
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .rose-modal-close:hover {
            background: rgba(255,255,255,0.2);
            color: var(--fg);
        }

        .rose-modal-apps {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            max-height: 400px;
            padding-right: 8px;
        }

        .rose-modal-app {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            background: var(--surface-2);
            border-radius: 14px;
            cursor: pointer;
            transition: background 0.2s, transform 0.15s, box-shadow 0.2s;
            border: 1px solid transparent;
        }

        .rose-modal-app:hover {
            background: var(--surface-3);
            transform: translateX(4px);
            border-color: rgba(255,255,255,0.1);
        }

        .rose-modal-app-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            overflow: hidden;
            background: var(--surface-3);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .rose-modal-app-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .rose-modal-app-info {
            flex: 1;
            min-width: 0;
        }

        .rose-modal-app-name {
            font-weight: 500;
            color: var(--fg);
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .rose-modal-app-score {
            font-size: 12px;
            color: var(--muted);
            margin-top: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rose-modal-app-arrow {
            color: var(--muted);
            font-size: 16px;
            opacity: 0.5;
            transition: opacity 0.2s, transform 0.2s;
        }

        .rose-modal-app:hover .rose-modal-app-arrow {
            opacity: 1;
            transform: translateX(3px);
        }

        /* Average Score Widget */
        .avg-score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .avg-score-svg {
            width: 120px;
            height: 120px;
        }

        .avg-score-label {
            margin-top: 8px;
            font-size: 12px;
            color: var(--muted);
        }

        /* Critical Apps Widget */
        .critical-apps-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            width: 100%;
            height: 100%;
            align-content: center;
            justify-content: center;
        }

        .critical-app-item {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--surface-2);
            border-radius: 12px;
            padding: 6px;
            cursor: pointer;
            transition: transform 0.2s, background 0.15s, box-shadow 0.2s;
            overflow: hidden;
            width: calc(25% - 6px);
            min-width: 40px;
            max-width: 52px;
        }

        .critical-app-item:hover {
            transform: scale(1.12);
            background: #1b2029;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
        }

        .critical-app-icon {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            overflow: hidden;
            background: #0d0e10;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .critical-app-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Stat widgets (Retention, AI Training) */
        .widget-clickable {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .widget-clickable:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 32px rgba(0, 0, 0, .55);
        }

        .widget-stat-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            gap: 4px;
        }

        .widget-stat-icon {
            font-size: 36px;
            margin-bottom: 4px;
        }

        .widget-stat-icon-img {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 6px;
            background: var(--surface-2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .widget-stat-icon-img img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .widget-stat-icon-img:empty {
            display: none;
        }

        .widget-stat-big {
            font-size: 28px;
            font-weight: 700;
            color: var(--fg);
            line-height: 1.1;
        }

        .widget-stat-sub {
            font-size: 12px;
            color: var(--muted);
            line-height: 1.3;
            max-width: 140px;
        }

        .widget-empty {
            color: var(--muted);
            font-size: 13px;
            text-align: center;
        }

        @media (max-width: 1200px) {
            .dashboard-grid {
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: 320px 160px 160px 320px;
            }
            .widget-2x2 {
                grid-column: span 2;
                grid-row: span 1;
            }
            .widget-1x1 {
                grid-column: span 1;
                grid-row: span 1;
            }
            #widgetRoseHistogram {
                grid-row: 4 / span 1;
            }
        }

        @media (max-width: 700px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(4, 280px);
            }
            .widget-2x2,
            .widget-1x1 {
                grid-column: span 1;
                grid-row: span 1;
            }
            #widgetRoseHistogram {
                grid-row: auto;
            }
        }
        
        /* ===== Toast Notifications ===== */
        .toast-container {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }
        
        .toast {
            background: var(--surface-1);
            border-radius: 12px;
            padding: 14px 18px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255,255,255,0.06) inset;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 280px;
            max-width: 400px;
            pointer-events: auto;
            animation: toast-slide-in 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-left: 4px solid var(--btn-active);
        }
        
        .toast.toast-success {
            border-left-color: var(--success);
        }
        
        .toast.toast-error {
            border-left-color: var(--coral-core);
        }
        
        .toast.toast-warning {
            border-left-color: var(--amber-core);
        }
        
        .toast.toast-exit {
            animation: toast-slide-out 0.25s ease-in forwards;
        }
        
        .toast-icon {
            font-size: 20px;
            flex-shrink: 0;
        }
        
        .toast-content {
            flex: 1;
            min-width: 0;
        }
        
        .toast-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--txt);
            margin-bottom: 2px;
        }
        
        .toast-message {
            font-size: 13px;
            color: var(--muted);
            line-height: 1.4;
        }
        
        .toast-close {
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            padding: 4px;
            font-size: 18px;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .toast-close:hover {
            opacity: 1;
        }
        
        @keyframes toast-slide-in {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes toast-slide-out {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        /* ===== Skeleton Loading ===== */
        .skeleton {
            background: linear-gradient(90deg, var(--surface-2) 25%, var(--surface-3) 50%, var(--surface-2) 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s ease-in-out infinite;
            border-radius: 8px;
        }
        
        .skeleton-text {
            height: 14px;
            margin-bottom: 8px;
            border-radius: 4px;
        }
        
        .skeleton-text.short {
            width: 60%;
        }
        
        .skeleton-text.medium {
            width: 80%;
        }
        
        .skeleton-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
        }
        
        .skeleton-chip {
            width: 80px;
            height: 26px;
            border-radius: 999px;
            display: inline-block;
            margin: 3px;
        }
        
        .skeleton-card {
            background: var(--surface-2);
            border-radius: 12px;
            padding: 14px;
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }
        
        @keyframes skeleton-shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        /* ===== Empty State Animations ===== */
        .empty-state-icon {
            animation: empty-state-pulse 3s ease-in-out infinite;
        }
        
        @keyframes empty-state-pulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.5;
            }
            50% { 
                transform: scale(1.1);
                opacity: 0.7;
            }
        }
        
        /* ===== Control buttons with icons ===== */
        #controls button {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        #controls button .btn-icon {
            font-size: 12px;
            opacity: 0.85;
            line-height: 1;
        }
        
        /* ===== Keyboard shortcut hint ===== */
        .search-hint {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--surface-1);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 2px 8px;
            font-size: 11px;
            color: var(--muted);
            font-family: var(--font-mono);
            pointer-events: none;
            transition: opacity 0.2s;
        }
        
        #searchInput:focus ~ .search-hint,
        #searchInput:not(:placeholder-shown) ~ .search-hint {
            opacity: 0;
        }
        
        /* ===== App loading state ===== */
        .app-list-item.loading {
            pointer-events: none;
        }
        
        .app-list-item.loading .app-list-icon {
            position: relative;
        }
        
        .app-list-item.loading .app-list-icon::after {
            content: '';
            position: absolute;
            inset: 0;
            border: 2px solid transparent;
            border-top-color: var(--btn-active);
            border-radius: 12px;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
<!-- Brand header -->
<header id="brandBar">
    <div class="brand-inner">
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 16px;">
            <div>
                <div class="brand-title">Cyberlytica</div>
                <div class="brand-sub">Privacy Risks Explorer</div>
            </div>
            <div style="display: flex; align-items: center; gap: 12px;">
                <div class="top-switcher" id="topSwitcher">
                    <button class="top-switcher-btn" data-view="dashboard">Dashboard</button>
                    <button class="top-switcher-btn active" data-view="myapps">My Apps</button>
                </div>
                <button class="settings-btn" id="settingsBtn">⚙️ Settings</button>
            </div>
        </div>
    </div>
</header>

<!-- Main container - always visible -->
<div class="main-container">
    <!-- Left panel - always visible -->
    <div class="left-panel">
        <!-- Search section -->
        <div class="search-section">
            <div class="search-wrap">
                <input id="searchInput" type="text" placeholder="Search app…"
                       autocomplete="off" aria-label="Search for apps"/>
                <span class="search-hint">/</span>
                <div id="suggestions"></div>
            </div>
            <button class="import-btn" id="importAppsBtn">Import Apps</button>
        </div>

        <!-- Analyze section (disabled for now, placeholder) -->
        <div class="analyze-section hidden" id="analyzeSection">
            <button class="analyze-btn" id="analyzeBtn" disabled>
                <div class="analyze-icon">📊</div>
                <div class="analyze-text">Multi-app comparison (coming soon)</div>
            </button>
        </div>

        <!-- App list section -->
        <div class="app-list-section">
            <div class="app-list-header">Selected Apps</div>
            <div class="app-list" id="appList">
                <div class="empty-state">
                    <div class="empty-state-icon">📱</div>
                    <div class="empty-state-text">No apps selected</div>
                    <div class="empty-state-subtext">Search and select apps to view their privacy details</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Right panel -->
    <div class="right-panel">
        <!-- Dashboard View (aggregate widgets) -->
        <div class="right-view dashboard-right-view" id="dashboardRightView">
            <div class="dashboard-grid" id="dashboardGrid">
                <!-- Your Privacy Score: position 1-1 -->
                <div class="widget widget-1x1" id="widgetAvgScore" style="grid-row: 1; grid-column: 1;">
                    <div class="widget-title">Your Privacy Score</div>
                    <div class="widget-content">
                        <div class="avg-score-container">
                            <svg class="avg-score-svg" id="avgScoreSvg"></svg>
                            <div class="avg-score-label" id="avgScoreLabel">— / 10</div>
                        </div>
                    </div>
                </div>

                <!-- Your most risky Apps: position 1-2 -->
                <div class="widget widget-1x1" id="widgetCriticalApps" style="grid-row: 1; grid-column: 2;">
                    <div class="widget-title">Your most risky Apps</div>
                    <div class="widget-content">
                        <div class="critical-apps-grid" id="criticalAppsGrid">
                            <div class="widget-empty">Add apps to see critical ones</div>
                        </div>
                    </div>
                </div>

                <!-- Data collected about you: position 1-3 (2x2 widget) -->
                <div class="widget widget-2x2" id="widgetCirclePacking" style="grid-row: 1 / span 2; grid-column: 3 / span 2;">
                    <div class="widget-title">Data collected about you</div>
                    <div class="widget-content">
                        <svg class="circle-packing-svg" id="circlePackingSvg"></svg>
                    </div>
                </div>

                <!-- Your risks: position 2-1 (2x2 widget) -->
                <div class="widget widget-2x2" id="widgetRoseHistogram" style="grid-row: 2 / span 2; grid-column: 1 / span 2;">
                    <div class="widget-title">Your risks</div>
                    <div class="widget-content">
                        <svg class="rose-histogram-svg" id="roseHistogramSvg"></svg>
                    </div>
                </div>

                <!-- Data Retention: position 3-3 (1x1 widget) -->
                <div class="widget widget-1x1 widget-clickable" id="widgetRetention" style="grid-row: 3; grid-column: 3;">
                    <div class="widget-content widget-stat-content">
                        <div class="widget-stat-icon-img" id="retentionAppIcon"></div>
                        <div class="widget-stat-big" id="retentionBigText">—</div>
                        <div class="widget-stat-sub" id="retentionSubText">Loading...</div>
                    </div>
                </div>

                <!-- AI Training: position 3-4 (1x1 widget) -->
                <div class="widget widget-1x1 widget-clickable" id="widgetAITraining" style="grid-row: 3; grid-column: 4;">
                    <div class="widget-content widget-stat-content">
                        <div class="widget-stat-icon">🤖</div>
                        <div class="widget-stat-big" id="aiTrainingBigText">—</div>
                        <div class="widget-stat-sub" id="aiTrainingSubText">Loading...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- My Apps View (app details) -->
        <div class="right-view myapps-right-view active" id="myAppsRightView">
            <!-- App details section -->
            <div class="app-details-section">
                <div class="app-header" id="appHeader">
                    <div class="app-row">
                        <div class="app-icon"></div>
                        <div class="app-meta">
                            <h2 class="app-name"></h2>
                            <p class="app-desc"></p>
                            <div class="app-extra"></div>

                            <div class="app-footer-row">
                                <div class="app-score" id="appScore">
                                    Privacy risk score: — / 10 (placeholder)
                                </div>
                                <div class="view-toggle">
                                    <button class="view-toggle-btn active" data-view="dashboard">Dashboard</button>
                                    <button class="view-toggle-btn" data-view="json">JSON</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="empty-state" id="appDetailsEmpty">
                    <div class="empty-state-icon">🔍</div>
                    <div class="empty-state-text">Select an app to view details</div>
                    <div class="empty-state-subtext">Choose an app from the list to see its privacy information</div>
                </div>
            </div>

            <div id="dashboardView" class="view-panel visible-view">

            <div class="risk-panel-section">
                <div class="risk-panel-header">
                    <!--                <span>Privacy risk profile</span>-->
                    <span id="riskPanelMeta" class="risk-panel-empty">No risk scores available yet</span>
                </div>
                <div id="riskPanelEmpty" class="risk-panel-empty">
                    We have not computed risk scores for this app yet.
                </div>
                <div id="riskPanelInner" class="risk-panel-inner" style="display:none;">
                    <div class="risk-gauge-container">
                        <div class="risk-gauge-title">Overall risk</div>
                        <svg id="riskGaugeSvg" class="risk-gauge-svg"></svg>
                        <div id="riskGaugeValue" class="risk-gauge-value">— / 10</div>
                    </div>
                    <div class="risk-radar-container">

                        <svg id="riskRadarSvg" class="risk-radar-svg"></svg>

                    </div>
                </div>
            </div>

            <!-- Controls section -->
            <div class="controls-section">
                <div id="controls">
                    <button data-mode="data" class="active"><span class="btn-icon">📊</span> Data collected</button>
                    <button data-mode="purpose"><span class="btn-icon">🎯</span> Purposes</button>
                    <button data-mode="sharing"><span class="btn-icon">🔗</span> Sharing</button>
                    <button data-mode="ai"><span class="btn-icon">🤖</span> AI</button>
                    <button data-mode="security"><span class="btn-icon">🔒</span> Security</button>
                    <button data-mode="retention"><span class="btn-icon">⏱️</span> Data retention</button>
                    <button data-mode="rights"><span class="btn-icon">⚖️</span> Rights</button>
                    <button data-mode="darkpatterns"><span class="btn-icon">🎭</span> Dark patterns</button>
                </div>
            </div>

            <!-- Visualization section -->
            <div class="viz-section">
                <div id="groups">
                    <div class="empty-state">
                        <div class="empty-state-icon">ℹ️</div>
                        <div class="empty-state-text">No privacy data loaded</div>
                        <div class="empty-state-subtext">Pick an app on the left to inspect its privacy behaviour</div>
                    </div>
                </div>
            </div>
        </div>

            <div class="json-section view-panel hidden-view" id="jsonView">
                <div class="json-header">
                    <span>Raw privacy JSON</span>
                    <button id="copyJsonBtn" type="button">Copy</button>
                </div>
                <pre id="jsonCode" class="json-code">// Select an app to see JSON</pre>
            </div>
        </div>
    </div>
</div>

<div id="tooltip"></div>

<!-- Toast notifications container -->
<div class="toast-container" id="toastContainer"></div>

<!-- Category Detail Modal -->
<div class="category-modal-overlay" id="categoryModalOverlay">
    <div class="category-modal" id="categoryModal">
        <div class="category-modal-header">
            <div class="category-modal-icon" id="categoryModalIcon">📊</div>
            <div class="category-modal-title-wrap">
                <h3 class="category-modal-title" id="categoryModalTitle">Category</h3>
                <div class="category-modal-subtitle" id="categoryModalSubtitle">0 apps collect this data</div>
            </div>
            <button class="category-modal-close" id="categoryModalClose">×</button>
        </div>
        <div class="category-modal-body">
            <div class="category-modal-apps" id="categoryModalApps"></div>
        </div>
    </div>
</div>

<!-- Rose Histogram Modal -->
<div class="rose-modal-overlay" id="roseModalOverlay">
    <div class="rose-modal" id="roseModal">
        <div class="rose-modal-header">
            <div class="rose-modal-icon" id="roseModalIcon">📊</div>
            <div class="rose-modal-titles">
                <div class="rose-modal-title" id="roseModalTitle">Metric</div>
                <div class="rose-modal-subtitle" id="roseModalSubtitle">0 apps</div>
            </div>
            <button class="rose-modal-close" id="roseModalClose">×</button>
        </div>
        <div class="rose-modal-apps" id="roseModalApps"></div>
    </div>
</div>

<!-- Settings Modal -->
<div class="settings-modal-overlay" id="settingsModalOverlay">
    <div class="settings-modal">
        <div class="settings-modal-header">
            <div class="settings-modal-title">⚙️ Settings</div>
            <button class="settings-modal-close" id="settingsModalClose">×</button>
        </div>
        <div class="settings-modal-body">
            <!-- Account Section -->
            <div class="settings-section">
                <div class="settings-section-title">👤 Account</div>
                <div class="settings-section-content">
                    <div class="settings-user-info">
                        <span class="settings-user-email" id="settingsUserEmail">Not logged in</span>
                        <button class="settings-logout-btn" id="settingsLogoutBtn">Log Out</button>
                    </div>
                </div>
            </div>
            
            <!-- How to Use Section -->
            <div class="settings-section">
                <div class="settings-section-title">💡 How to Use</div>
                <div class="settings-section-content settings-instructions">
                    <p><strong>Navigation:</strong></p>
                    <p>• Press <span class="settings-kbd">1</span> to switch to <strong>Dashboard</strong> view</p>
                    <p>• Press <span class="settings-kbd">2</span> to switch to <strong>My Apps</strong> view</p>
                    <p>• Press <span class="settings-kbd">/</span> to focus the search bar</p>
                    <p>• Press <span class="settings-kbd">Esc</span> to close popups or clear search</p>
                    <p style="margin-top: 14px;"><strong>Adding Apps:</strong></p>
                    <p>• Use the <strong>search bar</strong> to find apps by name</p>
                    <p>• Click on an app from the suggestions to add it to your list</p>
                    <p>• View privacy details in the <strong>My Apps</strong> tab</p>
                    <p>• See aggregate risks in the <strong>Dashboard</strong> tab</p>
                </div>
            </div>
            
            <!-- Video Import Instructions -->
            <div class="settings-section">
                <div class="settings-section-title">📹 Import Apps from Video</div>
                <div class="settings-section-content">
                    <p style="font-size: 13px; color: var(--txt); margin: 0 0 14px;">
                        You can automatically import all your iPhone apps by recording your screen. Here's how:
                    </p>
                    <div class="settings-step">
                        <div class="settings-step-num">1</div>
                        <div class="settings-step-text">
                            <strong>Start screen recording</strong> on your iPhone (swipe down from top-right corner and tap the record button)
                        </div>
                    </div>
                    <div class="settings-step">
                        <div class="settings-step-num">2</div>
                        <div class="settings-step-text">
                            <strong>Go to your App Library</strong> by swiping left past all your home screens until you see the alphabetical list of all apps
                        </div>
                    </div>
                    <div class="settings-step">
                        <div class="settings-step-num">3</div>
                        <div class="settings-step-text">
                            <strong>Slowly scroll through</strong> the entire list of apps from A to Z. Take your time — the clearer the video, the better the results
                        </div>
                    </div>
                    <div class="settings-step">
                        <div class="settings-step-num">4</div>
                        <div class="settings-step-text">
                            <strong>Stop recording</strong> and save the video to your Photos
                        </div>
                    </div>
                    <div class="settings-step">
                        <div class="settings-step-num">5</div>
                        <div class="settings-step-text">
                            <strong>Click "Import Apps"</strong> button in this app and select your video file. We'll extract app names automatically!
                        </div>
                    </div>
                    <p style="font-size: 12px; color: var(--muted); margin: 14px 0 0; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.06);">
                        🔒 <strong>Privacy:</strong> Your video is processed locally in your browser. We never upload or store your video.
                    </p>
                </div>
            </div>
        </div>
        <div class="settings-footer">
            © Cyberlytica LTD • Privacy Risk Explorer v0.2
        </div>
    </div>
</div>

<!-- Video Import Overlay -->
<div id="videoImportOverlay">
    <div class="video-import-card">
        <button class="video-import-close" id="closeVideoImport">×</button>
        <h3>Import Apps from Video</h3>
        <div class="video-import-help" id="videoImportHelp">
            <p style="font-size: 13px; color: var(--txt); margin: 0 0 16px;">
                Automatically import all your iPhone apps by uploading a screen recording. Here's how to record:
            </p>
            <div class="settings-step">
                <div class="settings-step-num">1</div>
                <div class="settings-step-text">
                    <strong>Start screen recording</strong> on your iPhone (swipe down from top-right corner and tap the record button)
                </div>
            </div>
            <div class="settings-step">
                <div class="settings-step-num">2</div>
                <div class="settings-step-text">
                    <strong>Go to your App Library</strong> by swiping left past all your home screens until you see the alphabetical list of all apps
                </div>
            </div>
            <div class="settings-step">
                <div class="settings-step-num">3</div>
                <div class="settings-step-text">
                    <strong>Slowly scroll through</strong> the entire list from A to Z. Take your time — the clearer the video, the better!
                </div>
            </div>
            <div class="settings-step">
                <div class="settings-step-num">4</div>
                <div class="settings-step-text">
                    <strong>Stop recording</strong> and upload the video below
                </div>
            </div>
            <p style="font-size: 12px; color: var(--muted); margin: 16px 0 0; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.06);">
                🔒 <strong>Privacy:</strong> Your video is processed locally in your browser. We never upload or store your video.
            </p>
        </div>
        <div class="file-input-wrapper">
            <input type="file" id="videoInput" accept="video/*">
            <label for="videoInput" class="file-label">
                Choose Video File
            </label>
        </div>
        <div class="video-import-progress" id="videoImportProgress">
            <div class="video-import-progress-bar">
                <div class="video-import-progress-fill" id="videoImportProgressFill"></div>
            </div>
            <div class="video-import-progress-text" id="videoImportProgressText">Ready to analyze...</div>
            <div class="found-apps-strip" id="foundAppsStrip">
                <div class="found-apps-track" id="foundAppsTrack"></div>
            </div>
        </div>
    </div>
</div>

<!-- Password gate -->
<div id="gate">
    <div id="gateCard">
        <h3>Sign in to continue</h3>
        <form id="gateForm">
            <input id="gateEmail" type="email" placeholder="Email" required autocomplete="email"/>
            <input id="gatePass" type="password" placeholder="Password" required autocomplete="current-password"/>
            <button id="gateBtn" type="submit">Continue</button>
            <div id="gateErr"></div>
        </form>
    </div>
</div>

<!-- Firebase + App code -->
<script type="module">
    import {initializeApp} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
        getAuth,
        signInWithEmailAndPassword,
        signOut,
        onAuthStateChanged,
        browserSessionPersistence,
        setPersistence
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import {
        getFirestore,
        collection,
        getDocs,
        doc,
        getDoc,
        query,
        orderBy,
        limit,
        startAt,
        endAt,
        addDoc,
        serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const d3 = window.d3;
    
    /* ===== Toast Notification System ===== */
    const toastContainer = document.getElementById('toastContainer');
    
    // Local escape function for toast (escapeHtml defined later in script)
    function toastEscape(s = '') {
        return s.replace(/[&<>"']/g, m => ({'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;'}[m]));
    }
    
    function showToast(options = {}) {
        const {
            title = '',
            message = '',
            type = 'info', // 'info' | 'success' | 'error' | 'warning'
            duration = 4000,
            icon = null
        } = options;
        
        const icons = {
            info: 'ℹ️',
            success: '✅',
            error: '❌',
            warning: '⚠️'
        };
        
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.innerHTML = `
            <span class="toast-icon">${icon || icons[type]}</span>
            <div class="toast-content">
                ${title ? `<div class="toast-title">${toastEscape(title)}</div>` : ''}
                <div class="toast-message">${toastEscape(message)}</div>
            </div>
            <button class="toast-close" aria-label="Close notification">×</button>
        `;
        
        const closeBtn = toast.querySelector('.toast-close');
        closeBtn.addEventListener('click', () => removeToast(toast));
        
        toastContainer.appendChild(toast);
        
        // Auto-remove after duration
        if (duration > 0) {
            setTimeout(() => removeToast(toast), duration);
        }
        
        return toast;
    }
    
    function removeToast(toast) {
        if (!toast || !toast.parentNode) return;
        toast.classList.add('toast-exit');
        toast.addEventListener('animationend', () => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        });
    }
    
    // Convenience functions
    function toastSuccess(message, title = 'Success') {
        return showToast({ title, message, type: 'success' });
    }
    
    function toastError(message, title = 'Error') {
        return showToast({ title, message, type: 'error', duration: 6000 });
    }
    
    function toastWarning(message, title = 'Warning') {
        return showToast({ title, message, type: 'warning' });
    }
    
    function toastInfo(message, title = '') {
        return showToast({ title, message, type: 'info' });
    }

    let dataTypeRiskMap = {};
    let purposeRiskMap = {};
    let riskTablesLoaded = false;

    let lastGaugeValue = null;
    let lastRadarValues = null;
    let radarInitialized = false;

    let currentView = 'dashboard';   // 'dashboard' | 'json'
    let currentAppRaw = null;        // полный документ App
    let lastJsonSource = '';         // строка JSON для копирования

    function loadRiskTables() {
        if (riskTablesLoaded) return Promise.resolve();

        return Promise.all([
            d3.csv('data_type_risk_weights.csv'),
            d3.csv('purpose_risk_weights.csv')
        ]).then(([dtRows, ppRows]) => {
            dataTypeRiskMap = {};
            dtRows.forEach(row => {
                if (row.field_id && row.sensitivity_band) {
                    dataTypeRiskMap[row.field_id] = (row.sensitivity_band || '').toUpperCase();
                }
            });

            purposeRiskMap = {};
            ppRows.forEach(row => {
                if (row.field_id && row.risk_band) {
                    purposeRiskMap[row.field_id] = (row.risk_band || '').toUpperCase();
                }
            });

            riskTablesLoaded = true;
            // если уже открыт апп и мы на нужной вкладке — перерисуем
            if (currentPrivacy && (currentMode === 'data' || currentMode === 'purpose')) {
                renderPrivacyForCurrentMode();
            }
        }).catch(err => {
            console.error('Failed to load risk weight tables', err);
        });
    }

    // запустить загрузку сразу
    loadRiskTables();

    const firebaseConfig = {
        apiKey: "AIzaSyCOsjAtEaNLpMtTMTFjY6CylzfvhHrFjfo",
        authDomain: "poli-db.firebaseapp.com",
        projectId: "poli-db",
        storageBucket: "poli-db.firebasestorage.app",
        messagingSenderId: "515718309045",
        appId: "1:515718309045:web:9806f377bf7b48ef758afc",
        measurementId: "G-SL0SS8G23G"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    
    // Set session persistence - requires login after browser/tab is closed
    setPersistence(auth, browserSessionPersistence).catch((err) => {
        console.error('Failed to set auth persistence:', err);
    });

    let allAppsCache = [];
    let allAppsLoaded = false;

    async function loadAllAppsOnce() {
        if (allAppsLoaded) return allAppsCache;

        const snap = await getDocs(collection(db, 'Apps'));
        allAppsCache = snap.docs.map(d => ({id: d.id, ...(d.data() || {})}));
        allAppsLoaded = true;
        return allAppsCache;
    }

    // UI refs
    const gate = document.getElementById('gate');
    const gateForm = document.getElementById('gateForm');
    const gateEmail = document.getElementById('gateEmail');
    const gatePass = document.getElementById('gatePass');
    const gateErr = document.getElementById('gateErr');

    const searchInput = document.getElementById('searchInput');
    const suggestions = document.getElementById('suggestions');
    const importAppsBtn = document.getElementById('importAppsBtn');
    const videoImportOverlay = document.getElementById('videoImportOverlay');
    const videoInput = document.getElementById('videoInput');
    const closeVideoImport = document.getElementById('closeVideoImport');
    const videoImportProgress = document.getElementById('videoImportProgress');
    const videoImportProgressFill = document.getElementById('videoImportProgressFill');
    const videoImportProgressText = document.getElementById('videoImportProgressText');
    const foundAppsStrip = document.getElementById('foundAppsStrip');
    const foundAppsTrack = document.getElementById('foundAppsTrack');
    const videoImportHelp = document.getElementById('videoImportHelp');

    const appListEl = document.getElementById('appList');
    const appHeaderEl = document.getElementById('appHeader');
    const appDetailsEmptyEl = document.getElementById('appDetailsEmpty');
    const appScoreEl = document.getElementById('appScore');

    const riskPanelInner = document.getElementById('riskPanelInner');
    const riskPanelEmpty = document.getElementById('riskPanelEmpty');
    const riskPanelMeta = document.getElementById('riskPanelMeta');
    const riskGaugeSvgSel = d3.select('#riskGaugeSvg');
    const riskRadarSvgSel = d3.select('#riskRadarSvg');
    const riskGaugeValueEl = document.getElementById('riskGaugeValue');

    const analyzeSectionEl = document.getElementById('analyzeSection');
    const analyzeBtnEl = document.getElementById('analyzeBtn');

    const dashboardViewEl = document.getElementById('dashboardView');
    const jsonViewEl = document.getElementById('jsonView');
    const jsonCodeEl = document.getElementById('jsonCode');
    const copyJsonBtn = document.getElementById('copyJsonBtn');

    const groupsEl = document.getElementById('groups');
    const MODE_ORDER = [
        'data',
        'purpose',
        'sharing',
        'ai',
        'security',
        'retention',
        'rights',
        'darkpatterns'
    ];
    const tooltip = document.getElementById('tooltip');

    let selectedApps = new Map(); // Map<appId, appData>
    let selectedAppId = null;
    let currentPrivacy = null;
    let currentMode = 'data';

    // Video import constants
    const REQUESTED_BY = 'client_5.html';
    let extractedApps = new Set();
    let normalizedApps = new Map(); // Map from normalized name to original variations
    let foundAppIds = new Set(); // trackIds already found during current import
    let foundAppIdOrder = []; // ordered list of found app IDs (for ticker UI)
    let foundAppsAnimating = false;
    const FOUND_APPS_MAX_VISIBLE = 10;
    const FOUND_APPS_ICON_SIZE = 44;
    const FOUND_APPS_GAP = 10;
    let foundAppIconCache = new Map(); // Map<appId, iconUrl>
    let matchedNormalized = new Set(); // normalized names already checked against DB during current import

    function resetVideoImportState() {
        extractedApps.clear();
        normalizedApps.clear();
        foundAppIds.clear();
        foundAppIdOrder = [];
        foundAppIconCache.clear();
        matchedNormalized.clear();
        if (foundAppsStrip) {
            foundAppsStrip.classList.remove('active');
            if (foundAppsTrack) foundAppsTrack.innerHTML = '';
        }
        if (videoImportHelp) videoImportHelp.classList.remove('hidden');
    }

    async function renderFoundAppsStripAnimate(newlyAddedId = null) {
        if (!foundAppsStrip || !foundAppsTrack) return;

        // If nothing found, hide.
        if (foundAppIdOrder.length === 0) {
            foundAppsStrip.classList.remove('active');
            foundAppsTrack.innerHTML = '';
            return;
        }

        foundAppsStrip.classList.add('active');

        // Center the strip based on max visible icons (fixed viewport).
        const viewportWidth = (FOUND_APPS_MAX_VISIBLE * FOUND_APPS_ICON_SIZE) + ((FOUND_APPS_MAX_VISIBLE - 1) * FOUND_APPS_GAP);
        foundAppsStrip.style.maxWidth = `${viewportWidth}px`;
        foundAppsStrip.style.width = '100%';

        // Initial fill (no animation): render last up to N items.
        if (!newlyAddedId && foundAppsTrack.children.length === 0) {
            const showIds = foundAppIdOrder.slice(Math.max(0, foundAppIdOrder.length - FOUND_APPS_MAX_VISIBLE));
            for (const id of showIds) {
                await appendFoundAppBubble(id, false);
            }
            // All icons start with .show class already (no animation needed for initial fill)
            return;
        }

        // For incremental updates: animate individual icons (no track transform)
        if (newlyAddedId) {
            if (foundAppsAnimating) return;
            foundAppsAnimating = true;

            const beforeCount = foundAppsTrack.children.length;
            const needsRemoval = beforeCount >= FOUND_APPS_MAX_VISIBLE;

            // If we need to remove the oldest, start its exit animation BEFORE adding new
            let exitingBubble = null;
            if (needsRemoval && foundAppsTrack.children.length > 0) {
                exitingBubble = foundAppsTrack.children[0];
                exitingBubble.classList.remove('show');
                exitingBubble.classList.add('exiting');
            }

            // Add new bubble with entering class (animation triggered inside appendFoundAppBubble)
            await appendFoundAppBubble(String(newlyAddedId), true);

            // After exit animation completes, remove the old bubble
            if (exitingBubble) {
                const onExitDone = () => {
                    exitingBubble.removeEventListener('transitionend', onExitDone);
                    if (exitingBubble.parentNode) {
                        exitingBubble.parentNode.removeChild(exitingBubble);
                    }
                    foundAppsAnimating = false;
                };
                exitingBubble.addEventListener('transitionend', onExitDone, { once: true });
                // Fallback in case transitionend doesn't fire
                setTimeout(() => {
                    if (exitingBubble.parentNode) {
                        exitingBubble.parentNode.removeChild(exitingBubble);
                    }
                    foundAppsAnimating = false;
                }, 350);
            } else {
                foundAppsAnimating = false;
            }
        }
    }

    async function appendFoundAppBubble(appId, animateEnter) {
        if (!foundAppsTrack) return;
        const id = String(appId);

        let url = foundAppIconCache.get(id);
        if (url === undefined) {
            try {
                const snap = await getDoc(doc(db, 'Apps', id));
                if (snap.exists()) {
                    const data = snap.data() || {};
                    url = data.logo_url || null;
                } else {
                    url = null;
                }
            } catch (err) {
                console.warn('Failed to load icon from database for app', id, err);
                url = null;
            }
            foundAppIconCache.set(id, url);
        }

        const bubble = document.createElement('div');
        // For initial fill: start with show class. For animated: start with entering (collapsed)
        bubble.className = 'app-icon-bubble' + (animateEnter ? ' entering' : ' show');
        bubble.title = `App ID: ${id}`;

        const spark = document.createElement('div');
        spark.className = 'spark';
        bubble.appendChild(spark);

        if (url) {
            const img = document.createElement('img');
            img.src = url;
            img.alt = `App ${id}`;
            bubble.appendChild(img);
        } else {
            const fallback = document.createElement('div');
            fallback.style.fontSize = '18px';
            fallback.style.opacity = '.7';
            fallback.textContent = '📱';
            bubble.appendChild(fallback);
        }

        foundAppsTrack.appendChild(bubble);

        // For animated entry: trigger expansion on next frame
        if (animateEnter) {
            // Double rAF ensures the browser has painted the collapsed state first
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    bubble.classList.remove('entering');
                    bubble.classList.add('show');
                    bubble.classList.add('pulse');
                    setTimeout(() => bubble.classList.remove('pulse'), 280);
                });
            });
        }
    }

    /* ===== Auth ===== */
    gateForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        gateErr.textContent = '';
        try {
            await signInWithEmailAndPassword(auth, gateEmail.value.trim(), gatePass.value);
        } catch (err) {
            console.error(err);
            gateErr.textContent = err?.message || 'Auth failed';
        }
    });

    onAuthStateChanged(auth, async (user) => {
        if (!user) {
            gate.style.display = 'grid';
            return;
        }
        gate.style.display = 'none';
        // Ничего больше не грузим на старте — ждём выбора аппки
    });
    
    /* ===== Settings Modal ===== */
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModalOverlay = document.getElementById('settingsModalOverlay');
    const settingsModalClose = document.getElementById('settingsModalClose');
    const settingsUserEmail = document.getElementById('settingsUserEmail');
    const settingsLogoutBtn = document.getElementById('settingsLogoutBtn');
    
    function openSettingsModal() {
        // Update email display
        const user = auth.currentUser;
        if (user && settingsUserEmail) {
            settingsUserEmail.textContent = user.email || 'Unknown';
        }
        settingsModalOverlay.classList.add('active');
    }
    
    function closeSettingsModal() {
        settingsModalOverlay.classList.remove('active');
    }
    
    if (settingsBtn) {
        settingsBtn.addEventListener('click', openSettingsModal);
    }
    
    if (settingsModalClose) {
        settingsModalClose.addEventListener('click', closeSettingsModal);
    }
    
    if (settingsModalOverlay) {
        settingsModalOverlay.addEventListener('click', (e) => {
            if (e.target === settingsModalOverlay) {
                closeSettingsModal();
            }
        });
    }
    
    // Logout handler inside settings
    if (settingsLogoutBtn) {
        settingsLogoutBtn.addEventListener('click', async () => {
            try {
                // Close settings modal first
                closeSettingsModal();
                
                // Clear all selected apps
                selectedApps.clear();
                selectedAppId = null;
                currentPrivacy = null;
                currentAppRaw = null;
                
                // Reset UI
                renderAppList();
                showEmptyAppDetails();
                clearGroupsWithEmptyState(
                    'No privacy data loaded',
                    'Pick an app on the left to inspect its privacy behaviour'
                );
                
                // Update dashboard if visible
                if (currentTopView === 'dashboard') {
                    renderDashboardWidgets();
                }
                
                // Sign out from Firebase
                await signOut(auth);
                
                // Clear form fields
                gateEmail.value = '';
                gatePass.value = '';
                gateErr.textContent = '';
                
                toastInfo('You have been logged out.', 'Goodbye');
            } catch (err) {
                console.error('Logout error:', err);
                toastError('Failed to log out. Please try again.', 'Logout Error');
            }
        });
    }

    /* ===== Helpers ===== */
    function escapeHtml(s = '') {
        return s.replace(/[&<>"']/g, m => ({'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;'}[m]));
    }

    function syntaxHighlight(jsonStr) {
        // сначала экранируем HTML
        let json = jsonStr
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

        return json.replace(
            /("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,
            (match) => {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return `<span class="${cls}">${match}</span>`;
            }
        );
    }

    function fixMojibake(s = '') {
        try {
            const x = decodeURIComponent(escape(s));
            return x || s;
        } catch {
            return s;
        }
    }

    function prettifyKey(raw) {
        if (!raw) return '';
        return raw
            .replace(/^cat_/, '')
            .replace(/^sub_/, '')
            .replace(/_/g, ' ')
            .replace(/\s+/g, ' ')
            .trim()
            .replace(/^\w/, c => c.toUpperCase());
    }

    function isMeaningfulField(field) {
        if (!field) return false;
        const v = field.value;
        if (v === null || v === undefined) return false;
        if (v === 'unknown') return false;
        if (Array.isArray(v) && v.length === 0) return false;
        // numeric 0 без цитаты считаем "не сказано"
        if (typeof v === 'number' && v === 0 && !field.supporting_citation) return false;
        return true;
    }

    function chipPresenceClass(v) {
        if (v === null || v === undefined) return 'chip-text';
        const s = String(v).toLowerCase().trim();
        if (s === 'present' || s === 'yes' || s === 'true') return 'chip-present';
        if (s === 'partial') return 'chip-partial';
        return 'chip-text';
    }

    function chipClassForValue(v) {
        return chipPresenceClass(v);
    }

    function bandRank(band) {
        const b = (band || '').toUpperCase();
        if (b === 'LOW') return 1;
        if (b === 'MED' || b === 'MEDIUM') return 2;
        if (b === 'HIGH') return 3;
        return 0;
    }

    function chipClassForBand(band) {
        const b = (band || '').toUpperCase();
        if (b === 'LOW') return 'chip-low';          // серый (low)
        if (b === 'MED' || b === 'MEDIUM') return 'chip-med'; // жёлтый (medium)
        if (b === 'HIGH') return 'chip-high';        // красный (high)
        return '';
    }

    function groupClassForBand(band) {
        const b = (band || '').toUpperCase();
        if (b === 'LOW') return 'group-risk-low';
        if (b === 'MED' || b === 'MEDIUM') return 'group-risk-med';
        if (b === 'HIGH') return 'group-risk-high';
        return '';
    }

    // Для вкладки Data collected: показываем только present / partial
    function isDataCollectedField(field) {
        if (!field) return false;
        const raw = field.value;
        if (raw === null || raw === undefined) return false;
        const lower = String(raw).toLowerCase().trim();
        return lower === 'present' || lower === 'partial';
    }

    function attachTooltipHandlers(el, text) {
        if (!text) return;
        el.addEventListener('mouseenter', () => {
            tooltip.textContent = text;
            const rect = el.getBoundingClientRect();
            tooltip.style.left = `${rect.left + rect.width / 2}px`;
            tooltip.style.top = `${rect.top - 10}px`;
            tooltip.style.opacity = 1;
        });
        el.addEventListener('mouseleave', () => {
            tooltip.style.opacity = 0;
        });
    }

    function createChip(label, value, citation, opts = {}) {
        const span = document.createElement('span');

        // базовый класс по типу значения (present/partial/text)
        let classes = [`chip`, chipClassForValue(value)];

        // риск по таблицам
        if (opts.domain && opts.fieldId) {
            let band = null;
            if (opts.domain === 'data_type') {
                band = dataTypeRiskMap[opts.fieldId];
            } else if (opts.domain === 'purpose') {
                band = purposeRiskMap[opts.fieldId];
            }
            if (band) {
                classes.push(chipClassForBand(band));
            }
        }

        span.className = classes.filter(Boolean).join(' ');
        span.textContent = label;
        attachTooltipHandlers(span, citation);
        return span;
    }

    function clearGroupsWithEmptyState(message, subtext) {
        groupsEl.innerHTML = '';
        const wrapper = document.createElement('div');
        wrapper.className = 'empty-state';
        wrapper.innerHTML = `
        <div class="empty-state-icon">ℹ️</div>
        <div class="empty-state-text">${escapeHtml(message)}</div>
        <div class="empty-state-subtext">${escapeHtml(subtext || '')}</div>
      `;
        groupsEl.appendChild(wrapper);
    }

    /* ===== Search & suggestions ===== */
    async function fetchLatest10() {
        const apps = await loadAllAppsOnce();

        // сортируем по времени скрейпа, если есть
        const sorted = [...apps].sort((a, b) => {
            const ta = a.scraped_at?.seconds ?? (a.scraped_at?.toDate ? a.scraped_at.toDate().getTime() / 1000 : 0);
            const tb = b.scraped_at?.seconds ?? (b.scraped_at?.toDate ? b.scraped_at.toDate().getTime() / 1000 : 0);
            return tb - ta; // новые вперёд
        });

        return sorted.slice(0, 10);
    }

    async function searchByNameLike(qstr) {
        if (!qstr) return [];
        const apps = await loadAllAppsOnce();

        const q = qstr.toLowerCase();

        // поиск по подстроке в name без учёта регистра
        const filtered = apps.filter(app =>
            (app.name || '').toLowerCase().includes(q)
        );

        // максимум 10 подсказок
        return filtered.slice(0, 10);
    }

    function showSuggestions(items) {
        suggestions.innerHTML = '';
        if (!items || !items.length) {
            suggestions.style.display = 'none';
            return;
        }
        items.forEach(it => {
            const div = document.createElement('div');
            div.className = 'sugg-item';
            div.innerHTML = `
          <div class="sugg-name">${escapeHtml(fixMojibake(it.name || '(no name)'))}</div>
          <div class="sugg-id">${it.id}</div>`;
            div.addEventListener('click', async () => {
                suggestions.style.display = 'none';
                searchInput.value = fixMojibake(it.name || '');
                await addAppToList(it.id, it);
            });
            suggestions.appendChild(div);
        });
        suggestions.style.display = 'block';
    }

    searchInput.addEventListener('focus', async () => {
        try {
            showSuggestions(await fetchLatest10());
        } catch (e) {
            console.error(e);
        }
    });

    const debounced = (fn, ms = 250) => {
        let t;
        return (...a) => {
            clearTimeout(t);
            t = setTimeout(() => fn(...a), ms);
        };
    };

    searchInput.addEventListener('input', debounced(async (e) => {
        const q = e.target.value.trim();
        try {
            if (!q) showSuggestions(await fetchLatest10());
            else showSuggestions(await searchByNameLike(q));
        } catch (err) {
            console.error(err);
        }
    }, 300));

    document.addEventListener('click', (e) => {
        const wrap = document.querySelector('.search-wrap');
        if (wrap && !wrap.contains(e.target)) suggestions.style.display = 'none';
    });

    /* ===== Video Import ===== */
    importAppsBtn.addEventListener('click', () => {
        videoImportOverlay.classList.add('active');
    });

    closeVideoImport.addEventListener('click', () => {
        videoImportOverlay.classList.remove('active');
        videoInput.value = '';
        videoImportProgress.classList.remove('active');
        resetVideoImportState();
    });

    videoImportOverlay.addEventListener('click', (e) => {
        if (e.target === videoImportOverlay) {
            videoImportOverlay.classList.remove('active');
            videoInput.value = '';
            videoImportProgress.classList.remove('active');
            resetVideoImportState();
        }
    });

    videoInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        videoImportOverlay.classList.add('active');
        videoImportProgress.classList.add('active');
        videoImportProgressFill.style.width = '0%';
        videoImportProgressText.textContent = 'Preparing video...';
        videoImportProgressText.style.color = '';
        resetVideoImportState();
        if (videoImportHelp) videoImportHelp.classList.add('hidden');

        try {
            await checkTesseractReady();
            await extractAppsFromVideo(file);
        } catch (error) {
            console.error('Error processing video:', error);
            videoImportProgressText.textContent = `Error: ${error.message}`;
            videoImportProgressText.style.color = '#ef4444';
            toastError(error.message || 'Failed to process video', 'Video Import Error');
        }
    });

    async function checkTesseractReady() {
        if (typeof Tesseract === 'undefined') {
            throw new Error('Tesseract.js not loaded. Please check your internet connection.');
        }
    }

    function isLikelyAppName(text) {
        if (!text || text.length < 2) return false;
        if (text.length > 50) return false; // Too long for app name
        
        // Filter out common non-app patterns
        const patterns = [
            /^\d+$/, // Pure numbers
            /^[^\w\s]+$/, // Only special characters
            /^(the|a|an|and|or|but|in|on|at|to|for|of|with|by)\s/i, // Common words
            /^(settings|home|back|search|menu|close|cancel|ok|yes|no)$/i, // UI elements
            /^(tap|click|swipe|scroll|drag|pinch)$/i, // Actions
            /^(loading|error|success|failed|complete)$/i, // Status messages
            /^https?:\/\//i, // URLs
            /^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$/i, // Email addresses
            /^\d{1,2}:\d{2}$/, // Time format
            /^\d{1,2}\/\d{1,2}\/\d{2,4}$/, // Date format
        ];
        
        for (const pattern of patterns) {
            if (pattern.test(text)) return false;
        }
        
        // Should have at least one letter
        if (!/[a-zA-Z]/.test(text)) return false;
        
        return true;
    }

    function normalizeAppName(name) {
        let normalized = name.trim();
        
        // Remove extra spaces
        normalized = normalized.replace(/\s+/g, ' ');
        
        // Remove leading/trailing special characters
        normalized = normalized.replace(/^[^\w]+|[^\w]+$/g, '');
        
        // Capitalize first letter of each word (common app name format)
        normalized = normalized.split(' ').map(word => {
            if (word.length === 0) return '';
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        }).join(' ');
        
        // Remove common suffixes that might be OCR errors
        normalized = normalized.replace(/\s+(Inc|LLC|Ltd|Corp|Co)$/i, '');
        
        return normalized;
    }

    function addExtractedAppName(rawName) {
        const normalized = normalizeAppName(rawName);
        if (normalized.length < 2) return null;

        if (!normalizedApps.has(normalized)) {
            normalizedApps.set(normalized, []);
        }
        const vars = normalizedApps.get(normalized);
        if (!vars.includes(rawName)) vars.push(rawName);
        return normalized;
    }

    function normalizeApps() {
        normalizedApps.clear();
        for (const appName of extractedApps) {
            addExtractedAppName(appName);
        }
    }

    function extractAppNames(text) {
        const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        
        for (const line of lines) {
            if (isLikelyAppName(line)) {
                extractedApps.add(line);
                addExtractedAppName(line);
            }
        }
    }

    function levenshteinDistance(str1, str2) {
        const m = str1.length;
        const n = str2.length;
        const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
        
        for (let i = 0; i <= m; i++) dp[i][0] = i;
        for (let j = 0; j <= n; j++) dp[0][j] = j;
        
        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                if (str1[i - 1] === str2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(
                        dp[i - 1][j] + 1,
                        dp[i][j - 1] + 1,
                        dp[i - 1][j - 1] + 1
                    );
                }
            }
        }
        
        return dp[m][n];
    }

    // Search for app in database by name (token-based, stricter than fuzzy-substring)
    // Goal: find apps that are in DB but OCR has small variations (e.g. "Bolt" vs "Bolt - Taxi App"),
    // while avoiding false positives from generic/short OCR strings.
    function normalizeForMatch(s) {
        return String(s || '')
            .toLowerCase()
            .replace(/[^a-z0-9\s]/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
    }

    function significantTokens(tokens) {
        return tokens.filter(t => t.length >= 4);
    }

    function isGoodDbNameMatch(requestedRaw, candidateRaw) {
        const rNorm = normalizeForMatch(requestedRaw);
        const cNorm = normalizeForMatch(candidateRaw);
        if (!rNorm || !cNorm) return false;

        if (rNorm === cNorm) return true;

        const rTokens = rNorm.split(' ').filter(Boolean);
        const cTokens = cNorm.split(' ').filter(Boolean);
        if (rTokens.length === 0 || cTokens.length === 0) return false;

        const rSig = significantTokens(rTokens);
        const cSig = significantTokens(cTokens);

        // Single-word names: require the token to appear as a whole word (or as leading token),
        // and enforce a minimum length to avoid matching on "Go", "In", etc.
        if (rTokens.length === 1) {
            const r = rTokens[0];
            if (r.length < 4) return false; // too short → avoid false positives
            if (cTokens.includes(r)) return true;
            if (cNorm.startsWith(r + ' ')) return true;
            if (cNorm.startsWith(r + '-')) return true;

            // Fallback: small OCR typos (relative Levenshtein), but only for >=4 chars
            const dist = levenshteinDistance(rNorm, cNorm);
            const maxLen = Math.max(rNorm.length, cNorm.length);
            const rel = maxLen > 0 ? dist / maxLen : 1;
            return rel <= 0.30;
        }

        // Multi-word names: require overlap on significant tokens (>=4 chars)
        if (rSig.length > 0) {
            const overlap = new Set(rSig.filter(t => cSig.includes(t))).size;
            const ratio = overlap / rSig.length;
            if (ratio >= 0.5) return true;
        }

        // Conservative fuzzy fallback for multi-word names
        const dist = levenshteinDistance(rNorm, cNorm);
        const maxLen = Math.max(rNorm.length, cNorm.length);
        const rel = maxLen > 0 ? dist / maxLen : 1;
        return rel <= 0.25;
    }

    async function searchAppInDatabase(appName) {
        const apps = await loadAllAppsOnce();
        const searchTerm = String(appName || '').trim();
        if (!searchTerm) return null;

        const searchNorm = normalizeForMatch(searchTerm);
        if (!searchNorm) return null;

        // Exact match first (fast + precise)
        const exactMatch = apps.find(app =>
            normalizeForMatch(app.name || '') === searchNorm
        );
        if (exactMatch) return exactMatch;

        // Token-based / conservative fuzzy match
        const matched = apps.find(app => isGoodDbNameMatch(searchTerm, app.name || ''));
        return matched || null;
    }

    async function waitForAuth(maxWait = 2000) {
        if (auth.currentUser) return true;
        const startTime = Date.now();
        while (!auth.currentUser && (Date.now() - startTime) < maxWait) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        return !!auth.currentUser;
    }

    async function storeMissingApp(appName, retryCount = 0) {
        const maxRetries = 2;
        const retryDelay = 2000;
        
        try {
            await waitForAuth(2000);
            
            const appsRequestsRef = collection(db, 'apps_requests');
            const dataToWrite = {
                app_name: appName,
                datetime: serverTimestamp(),
                requested_by: REQUESTED_BY
            };
            
            const writePromise = addDoc(appsRequestsRef, dataToWrite);
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Write timeout')), 10000)
            );
            
            const docRef = await Promise.race([writePromise, timeoutPromise]);
            console.log(`✓ Stored missing app: ${appName} (ID: ${docRef.id})`);
            return docRef.id;
        } catch (error) {
            if (error.message === 'Write timeout') {
                console.warn(`⏱ Write timeout for ${appName} - may be queued offline`);
                return 'queued_offline';
            }
            
            if (error.code === 'permission-denied') {
                console.error(`❌ Permission denied for ${appName}`);
                return null;
            }
            
            if (retryCount < maxRetries && (
                error.code === 'unavailable' || 
                error.code === 'deadline-exceeded'
            )) {
                await new Promise(resolve => setTimeout(resolve, retryDelay));
                return await storeMissingApp(appName, retryCount + 1);
            }
            
            console.error(`Failed to store ${appName}:`, error.code || error.message);
            return null;
        }
    }

    async function extractAppsFromVideo(file) {
        resetVideoImportState();
        
        const video = document.createElement('video');
        video.src = URL.createObjectURL(file);
        video.muted = true;
        
        await new Promise((resolve) => {
            if (video.readyState >= 2) {
                resolve();
            } else {
                video.addEventListener('loadedmetadata', resolve, { once: true });
            }
        });

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Calculate crop dimensions: 20% left, 20% top, 25% right
        const cropLeft = video.videoWidth * 0.2;
        const cropTop = video.videoHeight * 0.2;
        const cropRight = video.videoWidth * 0.25;
        const cropWidth = video.videoWidth - cropLeft - cropRight;
        const cropHeight = video.videoHeight - cropTop;

        canvas.width = cropWidth;
        canvas.height = cropHeight;

        const duration = video.duration;
        const framesPerSecond = 4;
        const frameInterval = 1 / framesPerSecond;
        const samplePoints = [];
        
        const startTime = duration * 0.3;
        const endTime = duration * 0.95;
        
        for (let time = startTime; time <= endTime; time += frameInterval) {
            samplePoints.push(time);
        }

        videoImportProgressText.textContent = `Analyzing video... 0%`;
        await renderFoundAppsStripAnimate();

        for (let i = 0; i < samplePoints.length; i++) {
            const time = samplePoints[i];
            video.currentTime = time;

            await new Promise((resolve) => {
                video.addEventListener('seeked', resolve, { once: true });
            });

            await new Promise(resolve => setTimeout(resolve, 100));

            ctx.drawImage(
                video,
                cropLeft, cropTop, cropWidth, cropHeight,
                0, 0, cropWidth, cropHeight
            );

            const progress = ((i + 1) / samplePoints.length) * 100;
            videoImportProgressFill.style.width = `${progress}%`;
            
            // Count found apps so far
            const foundCount = foundAppIds.size;
            videoImportProgressText.textContent = `Analyzing video... ${Math.round(progress)}%${foundCount > 0 ? ` • Found ${foundCount} app${foundCount === 1 ? '' : 's'}` : ''}`;

            try {
                const { data: { text } } = await Tesseract.recognize(canvas, 'eng', {
                    logger: () => {} // Suppress detailed OCR logs
                });
                extractAppNames(text);

                // After each frame: try to match newly discovered normalized names against DB
                // and animate found app icons.
                await validateNewAppsSinceLastFrame(i + 1, samplePoints.length);
            } catch (error) {
                console.warn(`Error processing frame at ${time}s:`, error);
            }
        }

        // Final pass to catch anything not matched yet (lightweight)
        await validateNewAppsSinceLastFrame(samplePoints.length, samplePoints.length, true);
        
        URL.revokeObjectURL(video.src);
    }

    async function validateNewAppsSinceLastFrame(frameIdx, totalFrames, isFinal = false) {
        const names = Array.from(normalizedApps.keys());
        if (names.length === 0) return;

        // Only check names we haven't checked before
        const pending = names.filter(n => !matchedNormalized.has(n));
        if (pending.length === 0) return;

        // Limit per frame to keep UI responsive
        const batch = pending.slice(0, 6);

        for (const appName of batch) {
            matchedNormalized.add(appName);
            try {
                const foundApp = await searchAppInDatabase(appName);
                if (foundApp && foundApp.id) {
                    if (!foundAppIds.has(String(foundApp.id))) {
                        foundAppIds.add(String(foundApp.id));
                        foundAppIdOrder.push(String(foundApp.id));
                        // Add to selected apps immediately
                        await addAppToList(foundApp.id, foundApp);
                        await renderFoundAppsStripAnimate(foundApp.id);
                    }
                } else {
                    // Not found in DB -> store request (no UI mention)
                    await storeMissingApp(appName);
                }
            } catch (e) {
                console.warn('validateNewAppsSinceLastFrame error for', appName, e);
            }
        }
        // Progress text is updated in the main loop
    }

    async function validateAndAddApps() {
        const appsArray = Array.from(normalizedApps.keys());
        const totalApps = appsArray.length;
        let foundCount = 0;
        let storedCount = 0;

        for (let i = 0; i < appsArray.length; i++) {
            const appName = appsArray[i];
            const progress = ((i + 1) / totalApps) * 100;
            videoImportProgressFill.style.width = `${progress}%`;
            videoImportProgressText.textContent = `Verifying apps... ${Math.round(progress)}%${foundCount > 0 ? ` • Found ${foundCount}` : ''}`;

            try {
                const foundApp = await searchAppInDatabase(appName);
                if (foundApp) {
                    foundCount++;
                    // Add to selected apps
                    await addAppToList(foundApp.id, foundApp);
                } else {
                    // Store missing app
                    const docId = await storeMissingApp(appName);
                    if (docId) {
                        storedCount++;
                    }
                }
            } catch (error) {
                console.error(`Error checking ${appName}:`, error);
            }
        }

        videoImportProgressFill.style.width = '100%';
        videoImportProgressText.textContent = `Complete! Found ${foundCount} app${foundCount === 1 ? '' : 's'}.`;
        videoImportProgressText.style.color = '#22c55e';
        
        // Show success toast
        if (foundCount > 0) {
            toastSuccess(`Successfully imported ${foundCount} app${foundCount === 1 ? '' : 's'} from your video.`, 'Import Complete');
        } else {
            toastWarning('No apps were found in the video. Try recording the App Library screen.', 'No Apps Found');
        }

        // Close overlay after 2 seconds
        setTimeout(() => {
            videoImportOverlay.classList.remove('active');
            videoInput.value = '';
            videoImportProgress.classList.remove('active');
            videoImportProgressText.style.color = '';
        }, 2000);
    }

    /* ===== Left: app list management ===== */
    async function addAppToList(appId, appData) {
        if (selectedApps.has(appId)) return;
        try {
            // Always fetch full document to get privacy and ranking
            const snap = await getDoc(doc(db, 'Apps', String(appId)));
            if (!snap.exists()) {
                toastError('The requested app could not be found in our database.', 'App Not Found');
                return;
            }
            const fullData = {id: appId, ...snap.data()};
            
            // Merge with any existing appData (like from search)
            if (appData && appData.name && !fullData.name) {
                fullData.name = appData.name;
            }
            
            if (!fullData.logo_url) {
                // Try to get from database if not already loaded
                try {
                    const snap = await getDoc(doc(db, 'Apps', String(appId)));
                    if (snap.exists()) {
                        const data = snap.data() || {};
                        fullData.logo_url = data.logo_url || null;
                    }
                } catch (err) {
                    console.warn('Failed to load icon from database for app', appId, err);
                }
            }
            selectedApps.set(appId, fullData);
            renderAppList();
            updateAnalyzeButton();
            
            // Show success toast
            const appName = fullData.name || `App ${appId}`;
            toastSuccess(`"${appName}" added to your analysis list.`, 'App Added');

            if (selectedApps.size === 1) {
                selectApp(appId);
            }
        } catch (err) {
            console.error('Failed to add app to list:', err);
            toastError('Could not add app to your list. Please try again.', 'Failed to Add App');
        }
    }

    function removeAppFromList(appId) {
        const appData = selectedApps.get(appId);
        const appName = appData?.name || `App ${appId}`;
        selectedApps.delete(appId);
        renderAppList();
        updateAnalyzeButton();
        
        // Update dashboard widgets if on dashboard view
        if (currentTopView === 'dashboard') {
            renderDashboardWidgets();
        }
        
        // Show info toast
        toastInfo(`"${appName}" removed from your list.`, 'App Removed');
        
        if (selectedAppId === appId) {
            const remaining = Array.from(selectedApps.keys());
            if (remaining.length > 0) {
                selectApp(remaining[0]);
            } else {
                selectApp(null);
            }
        }
    }

    window.removeAppFromList = removeAppFromList;

    function selectApp(appId) {
        selectedAppId = appId;
        renderAppList();

        if (appId && selectedApps.has(appId)) {
            loadAndRenderApp(appId);
        } else {
            showEmptyAppDetails();
            clearGroupsWithEmptyState(
                'No privacy data loaded',
                'Pick an app on the left to inspect its privacy behaviour'
            );
        }
    }

    function renderAppList() {
        if (selectedApps.size === 0) {
            appListEl.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">📱</div>
            <div class="empty-state-text">No apps selected</div>
            <div class="empty-state-subtext">Search and select apps to view their privacy details</div>
          </div>
        `;
            return;
        }
        appListEl.innerHTML = '';
        selectedApps.forEach((appData, appId) => {
            const item = document.createElement('div');
            item.className = `app-list-item ${selectedAppId === appId ? 'selected' : ''}`;

            const iconUrl = appData.logo_url || null;
            const iconHtml = iconUrl
                ? `<img src="${iconUrl}" alt="${escapeHtml(appData.name || '')} icon" loading="lazy"/>`
                : `<span style="font-size:20px; opacity:.6;">📱</span>`;

            item.innerHTML = `
          <div class="app-list-item-content">
            <div class="app-list-icon">${iconHtml}</div>
            <div class="app-list-meta">
              <div class="app-list-name">${escapeHtml(fixMojibake(appData.name || '(no name)'))}</div>
              <div class="app-list-desc">${escapeHtml(fixMojibake(appData.description || ''))}</div>
              <div class="app-list-id">ID: ${escapeHtml(String(appId))}</div>
            </div>
          </div>
          <div class="app-list-actions">
            <button class="btn-delete" onclick="removeAppFromList('${appId}')">Delete</button>
          </div>
        `;

            item.addEventListener('click', (e) => {
                if (!e.target.classList.contains('btn-delete')) {
                    switchTopView('myapps');
                    selectApp(appId);
                }
            });

            appListEl.appendChild(item);
        });
    }

    function showEmptyAppDetails() {
        appHeaderEl.style.display = 'none';
        appDetailsEmptyEl.style.display = 'flex';
        appScoreEl.textContent = 'Privacy risk score: — / 10 (placeholder)';
    }

    function updateAnalyzeButton() {
        if (selectedApps.size === 0) {
            analyzeSectionEl.classList.add('hidden');
        } else {
            analyzeSectionEl.classList.remove('hidden');
        }
    }

    /* ===== Right: app header + privacy render ===== */
    function formatTs(ts) {
        try {
            let d = ts?.toDate
                ? ts.toDate()
                : (ts?.seconds
                        ? new Date(ts.seconds * 1000)
                        : (ts ? new Date(ts) : null)
                );
            if (!d || isNaN(+d)) return '—';
            return d.toLocaleString();
        } catch {
            return '—';
        }
    }

    // Removed fetchAppIcon - now using logo_url from database only

    async function loadAndRenderApp(appId) {
        try {
            const snap = await getDoc(doc(db, 'Apps', String(appId)));
            if (!snap.exists()) {
                toastError('App data could not be loaded.', 'App Not Found');
                return;
            }
            const data = snap.data() || {};
            const iconUrl = data.logo_url || null;

            // Сохраняем полный документ приложения (для JSON-вида)
            currentAppRaw = {id: appId, ...data};

            renderAppHeader({
                id: appId,
                name: data.name || '(no name)',
                description: data.description || '',
                scraped_at: data.scraped_at || null,
                icon: iconUrl
            });

            // Риски (из поля ranking)
            renderRiskPanel(data.ranking || null);

            currentPrivacy = data.privacy || null;
            renderPrivacyForCurrentMode();

            // Если сейчас включён JSON-режим — сразу перерисуем JSON
            if (currentView === 'json') {
                renderJsonView();
            }

            // === НОВОЕ: вертикальная анимация шапки и карточек ===
            animateAppHeaderVertical();
            animateGroupsVertical();

        } catch (err) {
            console.error(err);
            toastError('Failed to load app privacy data. Please try again.', 'Load Error');
        }
    }

    function renderAppHeader({id, name, description, scraped_at, icon}) {
        const when = formatTs(scraped_at);
        const iconHtml = icon
            ? `<img src="${icon}" alt="${escapeHtml(name)} icon" loading="lazy"/>`
            : `<span style="font-size:26px; opacity:.6;">📱</span>`;

        const appIconEl = appHeaderEl.querySelector('.app-icon');
        const appNameEl = appHeaderEl.querySelector('.app-name');
        const appDescEl = appHeaderEl.querySelector('.app-desc');
        const appExtraEl = appHeaderEl.querySelector('.app-extra');

        appIconEl.innerHTML = iconHtml;
        appNameEl.textContent = fixMojibake(name);
        appDescEl.textContent = fixMojibake(description || '');
        appExtraEl.innerHTML = `
        <span>App ID: <code>${escapeHtml(String(id))}</code></span>
        <span>Scanned: ${escapeHtml(when)}</span>
      `;

        appDetailsEmptyEl.style.display = 'none';
        appHeaderEl.style.display = 'block';

    }

    /* ===== Risk panel rendering ===== */

    const RADAR_METRICS = [
        {key: 'data_volume_risk', label: 'Data'},
        {key: 'sharing_risk', label: 'Sharing'},
        {key: 'ai_training_risk', label: 'AI'},
        {key: 'security_response_risk', label: 'Security'},
        {key: 'retention_risk', label: 'Retention'},
        {key: 'rights_risk', label: 'Rights'},
        {key: 'dark_patterns_risk', label: 'Dark patterns'},
        {key: 'agency_risk', label: 'Agency'},
    ];

    function renderJsonView() {
        if (!jsonCodeEl) return;

        if (!currentAppRaw) {
            lastJsonSource = '';
            jsonCodeEl.textContent = '// No app selected';
            return;
        }

        // Показываем ПОЛНЫЙ документ приложения,
        // чтобы были и privacy_policy, и ranking, и все скоры
        const sourceObj = currentAppRaw;
        const jsonStr = JSON.stringify(sourceObj, null, 2);
        lastJsonSource = jsonStr;
        jsonCodeEl.innerHTML = syntaxHighlight(jsonStr);
    }

    if (copyJsonBtn) {
        copyJsonBtn.addEventListener('click', async () => {
            if (!lastJsonSource) return;
            try {
                await navigator.clipboard.writeText(lastJsonSource);
                copyJsonBtn.classList.add('copied');
                const oldLabel = copyJsonBtn.textContent;
                copyJsonBtn.textContent = 'Copied';
                setTimeout(() => {
                    copyJsonBtn.classList.remove('copied');
                    copyJsonBtn.textContent = oldLabel;
                }, 1200);
            } catch (err) {
                console.error('Clipboard error', err);
                toastError('Could not copy to clipboard. Please try again.', 'Copy Failed');
            }
        });
    }

    function renderRiskPanel(ranking) {
        // нет ранкинга — показываем заглушку
        if (!ranking || typeof ranking !== 'object') {
            riskPanelInner.style.display = 'none';
            riskPanelEmpty.style.display = 'block';
            riskPanelMeta.textContent = 'No risk scores available yet';
            riskGaugeSvgSel.selectAll('*').remove();
            riskRadarSvgSel.selectAll('*').remove();
            riskGaugeValueEl.textContent = '— / 10';

            // сбрасываем состояние анимаций
            lastGaugeValue = null;
            lastRadarValues = null;
            radarInitialized = false;
            return;
        }

        riskPanelInner.style.display = 'flex';
        riskPanelEmpty.style.display = 'none';

        const overall = toNumberSafe(ranking.overall_privacy_risk, 0);
        const scoredAt = ranking.scored_at ? String(ranking.scored_at).split('.')[0] : '';
        riskPanelMeta.textContent = scoredAt ? `Scored at ${scoredAt}` : 'Risk scores available';

        // АНИМИРОВАННЫЙ gauge + радар
        renderRiskGauge(overall);
        renderRiskRadar(ranking);

        // Обновим текстовый скор под заголовком приложения
        if (!isNaN(overall) && overall > 0) {
            appScoreEl.textContent = `Privacy risk score: ${overall.toFixed(1)} / 10 (overall)`;
        } else {
            appScoreEl.textContent = 'Privacy risk score: — / 10';
        }
    }

    function toNumberSafe(v, fallback = 0) {
        const n = Number(v);
        return Number.isFinite(n) ? n : fallback;
    }

    function riskColor(value) {
        // 0..10 → slate → amber → coral (modern gradient spectrum)
        const t = Math.max(0, Math.min(10, value)) / 10;
        if (t < 0.35) {
            // Low risk: slate → amber-light
            const k = t / 0.35;
            return d3.interpolateRgb('#64748b', '#fbbf24')(k);
        } else if (t < 0.65) {
            // Medium risk: amber spectrum
            const k = (t - 0.35) / 0.30;
            return d3.interpolateRgb('#fbbf24', '#f59e0b')(k);
        } else {
            // High risk: amber-deep → coral-crimson
            const k = (t - 0.65) / 0.35;
            return d3.interpolateRgb('#d97706', '#dc2626')(k);
        }
    }

    function renderRiskGauge(overall) {
        const value = Math.max(0, Math.min(10, toNumberSafe(overall, 0)));

        const width = 220;
        const height = 220;
        const radius = 90;
        const innerRadius = 60;

        riskGaugeSvgSel.attr('viewBox', `0 0 ${width} ${height}`);

        // Ищем уже созданный root
        let root = riskGaugeSvgSel.select('g.gauge-root');

        if (root.empty()) {
            // Первый раз: строим структуру
            riskGaugeSvgSel.selectAll('*').remove();

            const defs = riskGaugeSvgSel.append('defs');
            
            // Gradient for gauge arc (amber to coral)
            const gaugeGradient = defs.append('linearGradient')
                .attr('id', 'gaugeGradient')
                .attr('x1', '0%')
                .attr('y1', '100%')
                .attr('x2', '100%')
                .attr('y2', '0%');
            gaugeGradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#64748b');
            gaugeGradient.append('stop')
                .attr('offset', '35%')
                .attr('stop-color', '#fbbf24');
            gaugeGradient.append('stop')
                .attr('offset', '65%')
                .attr('stop-color', '#f59e0b');
            gaugeGradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#dc2626');
            
            // Combined shadow + glow filter for gauge
            const shadow = defs.append('filter')
                .attr('id', 'shadowGauge')
                .attr('x', '-100%')
                .attr('y', '-100%')
                .attr('width', '300%')
                .attr('height', '300%');

            // Shadow effect
            shadow.append('feDropShadow')
                .attr('dx', 0)
                .attr('dy', 2)
                .attr('stdDeviation', 4)
                .attr('flood-color', '#000')
                .attr('flood-opacity', 0.45)
                .attr('result', 'shadow');

            // Glow effect
            shadow.append('feGaussianBlur')
                .attr('in', 'SourceGraphic')
                .attr('stdDeviation', '6')
                .attr('result', 'glow');
            shadow.append('feColorMatrix')
                .attr('in', 'glow')
                .attr('type', 'matrix')
                .attr('values', '1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.5 0')
                .attr('result', 'coloredGlow');
            const feMerge = shadow.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'coloredGlow');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            root = riskGaugeSvgSel.append('g')
                .attr('class', 'gauge-root')
                .attr('transform', `translate(${width / 2}, ${height / 2})`);

            const bgArc = d3.arc()
                .innerRadius(innerRadius)
                .outerRadius(radius);

            // фон
            root.append('path')
                .attr('class', 'gauge-bg')
                .attr('fill', '#111318')
                .attr('d', bgArc({startAngle: 0, endAngle: 2 * Math.PI}));

            // foreground (пока без d, зададим ниже через анимацию)
            root.append('path')
                .attr('class', 'gauge-fg')
                .attr('fill', riskColor(value))
                .attr('filter', 'url(#shadowGauge)');

            // центр
            root.append('circle')
                .attr('r', innerRadius - 10)
                .attr('fill', '#0f1115');

            root.append('text')
                .attr('class', 'gauge-value')
                .attr('text-anchor', 'middle')
                .attr('dy', '-4')
                .attr('font-size', '28')
                .attr('font-weight', '700')
                .attr('fill', '#e5e7eb')
                .text(value.toFixed(1));

            root.append('text')
                .attr('class', 'gauge-suffix')
                .attr('text-anchor', 'middle')
                .attr('dy', '18')
                .attr('font-size', '11')
                .attr('fill', '#9ca3af')
                .text('/ 10');

            // стартуем с 0, чтобы был первый “вылет” дуги
            lastGaugeValue = 0;
        }

        const angleScale = d3.scaleLinear()
            .domain([0, 10])
            .range([0, 2 * Math.PI]);

        const fgArc = d3.arc()
            .innerRadius(innerRadius)
            .outerRadius(radius);

        const fromAngle = angleScale(lastGaugeValue != null ? lastGaugeValue : 0);
        const toAngle = angleScale(value);

        const fgPath = root.select('path.gauge-fg');

        // Анимация дуги
        fgPath
            .transition()
            .duration(300)
            .attrTween('d', function () {
                const interp = d3.interpolateNumber(fromAngle, toAngle);
                return function (t) {
                    const currentAngle = interp(t);
                    return fgArc({startAngle: 0, endAngle: currentAngle});
                };
            })
            .attr('fill', riskColor(value));

        // Анимация цифр в центре
        const valueText = root.select('text.gauge-value');
        valueText
            .transition()
            .duration(300)
            .tween('text', function () {
                const node = this;
                const start = (lastGaugeValue != null ? lastGaugeValue : 0);
                const i = d3.interpolateNumber(start, value);
                return function (t) {
                    const v = i(t);
                    node.textContent = v.toFixed(1);
                };
            });

        // подпись под gauge
        riskGaugeValueEl.textContent = `${value.toFixed(1)} / 10`;

        // запоминаем последнее значение
        lastGaugeValue = value;
    }

    function renderRiskRadar(ranking) {
        const metrics = RADAR_METRICS.map(m => {
            return {
                ...m,
                value: Math.max(0, Math.min(10, toNumberSafe(ranking[m.key], 0)))
            };
        });

        const width = 520;
        const height = 260;
        const radius = 100;
        const centerX = width / 2;
        const centerY = height / 2;

        riskRadarSvgSel.attr('viewBox', `0 0 ${width} ${height}`);

        const angleSlice = (2 * Math.PI) / metrics.length;

        const line = d3.lineRadial()
            .radius(d => (d.value / 10) * radius)
            .angle((_, i) => i * angleSlice)
            .curve(d3.curveLinearClosed);

        let root = riskRadarSvgSel.select('g.radar-root');

        // ПЕРВЫЙ РАЗ: строим сетку, оси, подписи, полигон и точки
        if (root.empty()) {
            riskRadarSvgSel.selectAll('*').remove();

            // Add gradient definition for radar
            const defs = riskRadarSvgSel.append('defs');
            const radarGradient = defs.append('linearGradient')
                .attr('id', 'radarGradient')
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '100%')
                .attr('y2', '100%');
            radarGradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#fbbf24')
                .attr('stop-opacity', 0.45);
            radarGradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#dc2626')
                .attr('stop-opacity', 0.45);

            // Glow filter for radar
            const glowFilter = defs.append('filter')
                .attr('id', 'radarGlow')
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '200%')
                .attr('height', '200%');
            glowFilter.append('feGaussianBlur')
                .attr('stdDeviation', '3')
                .attr('result', 'coloredBlur');
            const feMerge = glowFilter.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'coloredBlur');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            root = riskRadarSvgSel.append('g')
                .attr('class', 'radar-root')
                .attr('transform', `translate(${centerX}, ${centerY})`);

            const levels = [3, 6, 9];

            levels.forEach(level => {
                const r = (level / 10) * radius;
                root.append('circle')
                    .attr('r', r)
                    .attr('fill', 'none')
                    .attr('stroke', '#4b5563')
                    .attr('stroke-width', 0.7)
                    .attr('stroke-dasharray', '2,3');
            });

            // оси + подписи
            metrics.forEach((m, i) => {
                const angle = i * angleSlice - Math.PI / 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                root.append('line')
                    .attr('x1', 0)
                    .attr('y1', 0)
                    .attr('x2', x)
                    .attr('y2', y)
                    .attr('stroke', '#374151')
                    .attr('stroke-width', 0.7);

                const labelRadius = radius + 18;
                const lx = Math.cos(angle) * labelRadius;
                const ly = Math.sin(angle) * labelRadius;

                const label = root.append('text')
                    .attr('class', 'radar-label')
                    .attr('x', lx)
                    .attr('y', ly)
                    .attr('text-anchor', lx < 0 ? 'end' : (Math.abs(lx) < 5 ? 'middle' : 'start'))
                    .attr('dominant-baseline', ly > 0 ? 'hanging' : 'auto')
                    .attr('font-size', 11)
                    .attr('fill', '#9ca3af')
                    .text(m.label);

                const node = label.node();
                if (node) {
                    node.style.cursor = 'default';
                    attachTooltipHandlers(node, `${m.label}: ${m.value.toFixed(1)} / 10`);
                }
            });

            // полигон – первый раз просто рисуем без анимации (можно из нулей, но не обязательно)
            root.append('path')
                .datum(metrics)
                .attr('class', 'radar-area')
                .attr('d', line)
                .attr('fill', 'url(#radarGradient)')
                .attr('stroke', 'url(#radarStrokeGradient)')
                .attr('stroke-width', 2)
                .attr('filter', 'url(#radarGlow)');

            // Add stroke gradient
            const strokeGradient = defs.append('linearGradient')
                .attr('id', 'radarStrokeGradient')
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '100%')
                .attr('y2', '100%');
            strokeGradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#fbbf24');
            strokeGradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#ef4444');

            // точки
            root.selectAll('circle.radar-point')
                .data(metrics)
                .enter()
                .append('circle')
                .attr('class', 'radar-point')
                .attr('r', 4)
                .attr('fill', '#fef3c7')
                .attr('stroke', '#f59e0b')
                .attr('stroke-width', 1.5)
                .attr('filter', 'url(#radarGlow)')
                .attr('cx', (d, i) => {
                    const angle = i * angleSlice - Math.PI / 2;
                    const r = (d.value / 10) * radius;
                    return Math.cos(angle) * r;
                })
                .attr('cy', (d, i) => {
                    const angle = i * angleSlice - Math.PI / 2;
                    const r = (d.value / 10) * radius;
                    return Math.sin(angle) * r;
                })
                .each(function (d) {
                    attachTooltipHandlers(this, `${d.label}: ${d.value.toFixed(1)} / 10`);
                });

            lastRadarValues = metrics.map(m => m.value);
            radarInitialized = true;
            return;
        }

        // ДАЛЬШЕ: обновляем с анимацией
        const prevValues = lastRadarValues || metrics.map(() => 0);
        const newValues = metrics.map(m => m.value);
        const interpolators = newValues.map((nv, i) =>
            d3.interpolateNumber(prevValues[i] ?? 0, nv)
        );

        const area = root.select('path.radar-area');

        // Анимация полигона
        area
            .datum(metrics)
            .transition()
            .duration(300)
            .attrTween('d', function (d) {
                return function (t) {
                    const cur = d.map((m, i) => ({
                        ...m,
                        value: interpolators[i](t)
                    }));
                    return line(cur);
                };
            });

        // Точки просто переезжают: D3 сам интерполирует cx/cy
        const points = root.selectAll('circle.radar-point')
            .data(metrics);

        points
            .transition()
            .duration(300)
            .attr('cx', (d, i) => {
                const angle = i * angleSlice - Math.PI / 2;
                const r = (d.value / 10) * radius;
                return Math.cos(angle) * r;
            })
            .attr('cy', (d, i) => {
                const angle = i * angleSlice - Math.PI / 2;
                const r = (d.value / 10) * radius;
                return Math.sin(angle) * r;
            });

        // Обновим тултипы для точек (слушателей будет несколько, но не страшно)
        points.each(function (d) {
            attachTooltipHandlers(this, `${d.label}: ${d.value.toFixed(1)} / 10`);
        });

        // Лейблы тоже можно обновить тултипами (на случай смены значений)
        const labels = root.selectAll('text.radar-label')
            .data(metrics);

        labels.each(function (d) {
            attachTooltipHandlers(this, `${d.label}: ${d.value.toFixed(1)} / 10`);
        });

        lastRadarValues = newValues;
    }

    /* ===== Controls (modes) ===== */
    document.querySelectorAll('#controls button').forEach(btn => {
        btn.addEventListener('click', () => {
            const newMode = btn.dataset.mode;
            if (!newMode || newMode === currentMode) return;

            const prevIndex = MODE_ORDER.indexOf(currentMode);
            const newIndex = MODE_ORDER.indexOf(newMode);

            // если вдруг что-то странное — просто без анимации
            if (prevIndex === -1 || newIndex === -1) {
                currentMode = newMode;
                document.querySelectorAll('#controls button').forEach(b => {
                    b.classList.toggle('active', b === btn);
                });
                renderPrivacyForCurrentMode();
                return;
            }

            // направление: вперёд по списку — въезжаем справа, назад — слева
            const directionClass = newIndex > prevIndex ? 'from-right' : 'from-left';

            currentMode = newMode;

            // обновляем активную кнопку
            document.querySelectorAll('#controls button').forEach(b => {
                b.classList.toggle('active', b === btn);
            });

            // сначала рендерим новые карточки...
            renderPrivacyForCurrentMode();
            // ...потом анимируем их въезд
            animateGroups(directionClass);
        });
    });

    function animateGroups(directionClass) {
        const el = groupsEl;
        if (!el) return;

        // сброс предыдущих классов
        el.classList.remove('from-left', 'from-right', 'no-transition');

        // 1) мгновенно ставим стартовое смещение без анимации
        el.classList.add('no-transition', directionClass);
        void el.offsetWidth; // форсим reflow

        // 2) включаем анимацию
        el.classList.remove('no-transition');

        // 3) на следующем кадре убираем смещение → едем к 0 с transition
        requestAnimationFrame(() => {
            el.classList.remove(directionClass);
        });
    }

    function animateGroupsVertical() {
        const el = groupsEl;
        if (!el) return;

        // сброс прошлых состояний
        el.classList.remove('from-top', 'no-transition', 'from-left', 'from-right');

        // 1) мгновенно ставим стартовое смещение вверх без анимации
        el.classList.add('no-transition', 'from-top');
        void el.offsetWidth; // форсим reflow

        // 2) включаем анимацию
        el.classList.remove('no-transition');

        // 3) на следующем кадре убираем смещение → едем вниз с transition
        requestAnimationFrame(() => {
            el.classList.remove('from-top');
        });
    }

    function animateAppHeaderVertical() {
        const el = appHeaderEl;
        if (!el || el.style.display === 'none') return;

        el.classList.remove('from-top', 'no-transition');

        // 1) стартовое положение – выше и прозрачная
        el.classList.add('no-transition', 'from-top');
        void el.offsetWidth;

        // 2) включаем анимацию
        el.classList.remove('no-transition');

        // 3) плавный выезд вниз
        requestAnimationFrame(() => {
            el.classList.remove('from-top');
        });
    }

    function switchView(view) {
        if (view === currentView) return;
        currentView = view;

        // Обновляем кнопки
        document.querySelectorAll('.view-toggle-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.view === view);
        });

        if (view === 'dashboard') {
            dashboardViewEl.classList.remove('hidden-view');
            dashboardViewEl.classList.add('visible-view');

            jsonViewEl.classList.remove('visible-view');
            jsonViewEl.classList.add('hidden-view');
        } else {
            // JSON
            jsonViewEl.classList.remove('hidden-view');
            jsonViewEl.classList.add('visible-view');

            dashboardViewEl.classList.remove('visible-view');
            dashboardViewEl.classList.add('hidden-view');

            renderJsonView();
        }
    }

    // Вешаем обработчики на кнопки переключателя
    document.querySelectorAll('.view-toggle-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const view = btn.dataset.view;
            if (!view) return;
            switchView(view);
        });
    });

    function renderPrivacyForCurrentMode() {
        if (!currentPrivacy) {
            clearGroupsWithEmptyState(
                'No privacy data available',
                'This app has no parsed privacy fields in the database'
            );
            return;
        }
        switch (currentMode) {
            case 'data':
                renderDataCollected(currentPrivacy.DataType || currentPrivacy.DataTypeInfo || null);
                break;
            case 'purpose':
                renderPurposes(currentPrivacy.Purpose || null);
                break;
            case 'sharing':
                renderSharing(currentPrivacy.DataShare || null, currentPrivacy.DataLocation || null);
                break;

            case 'ai':

                renderAITraining(currentPrivacy.UseToTrainAI || null);
                break;
            case 'security':
                renderSecurityAndBreach(
                    currentPrivacy.Security || null,
                    currentPrivacy.BreachNotification || null
                );
                break;
            case 'retention':
                renderRetention(
                    currentPrivacy.DataRetention &&
                    currentPrivacy.DataRetention.overall_policy
                        ? currentPrivacy.DataRetention.overall_policy
                        : null
                );
                break;
            case 'rights':
                renderRights(currentPrivacy.Rights || null);
                break;

            case 'darkpatterns':
                renderDarkPatterns(currentPrivacy.DarkPatterns || null);
                break;
            default:
                renderDataCollected(currentPrivacy.DataType || null);
        }
    }

    /* ===== Renderers ===== */

    function renderDataCollected(dataType) {
        groupsEl.innerHTML = '';

        if (!dataType || typeof dataType !== 'object') {
            clearGroupsWithEmptyState(
                'No explicit data types',
                'We only show concrete data categories explicitly marked as present or partial in the policy'
            );
            return;
        }

        const subMap = new Map();
        Object.entries(dataType).forEach(([catKey, subcats]) => {
            if (!subcats || typeof subcats !== 'object') return;

            Object.entries(subcats).forEach(([subKey, items]) => {
                if (!items || typeof items !== 'object') return;

                let list = subMap.get(subKey);
                if (!list) {
                    list = [];
                    subMap.set(subKey, list);
                }

                Object.entries(items).forEach(([itemKey, field]) => {
                    if (!isDataCollectedField(field)) return;
                    list.push({itemKey, field});
                });
            });
        });

        let anyShown = false;

        subMap.forEach((items, subKey) => {
            if (!items || !items.length) return;

            anyShown = true;

            const card = document.createElement('div');
            card.className = 'group';

            const title = document.createElement('div');
            title.className = 'group-title';
            title.textContent = prettifyKey(subKey);
            card.appendChild(title);

            const chipsWrap = document.createElement('div');
            chipsWrap.className = 'chips';

            let maxRank = 0;
            let maxBand = null;

            items.forEach(({itemKey, field}) => {
                const label = prettifyKey(itemKey);

                const chip = createChip(
                    label,
                    field.value,
                    field.supporting_citation || '',
                    {domain: 'data_type', fieldId: itemKey}
                );
                chipsWrap.appendChild(chip);

                const band = dataTypeRiskMap[itemKey];
                const rank = bandRank(band);
                if (rank > maxRank) {
                    maxRank = rank;
                    maxBand = band;
                }
            });

            if (maxRank > 0) {
                const gClass = groupClassForBand(maxBand);
                if (gClass) card.classList.add(gClass);
            } else {
                card.classList.add('group-border-weak');
            }

            card.appendChild(chipsWrap);
            groupsEl.appendChild(card);
        });

        if (!anyShown) {
            clearGroupsWithEmptyState(
                'No explicit data types found',
                'We only show data fields that are explicitly marked as present or partial in the policy'
            );
        }
    }

    function renderPurposes(purpose) {
        groupsEl.innerHTML = '';
        if (!purpose) {
            clearGroupsWithEmptyState(
                'No explicit purposes',
                'We did not detect explicit purposes for processing in this policy'
            );
            return;
        }

        let anyShown = false;

        Object.entries(purpose).forEach(([catKey, subcats]) => {
            if (!subcats || typeof subcats !== 'object') return;

            const card = document.createElement('div');
            card.className = 'group';

            const title = document.createElement('div');
            title.className = 'group-title';
            title.textContent = prettifyKey(catKey);
            card.appendChild(title);

            const chipsWrap = document.createElement('div');
            chipsWrap.className = 'chips';

            let cardHasItems = false;
            let maxRank = 0;
            let maxBand = null;

            Object.entries(subcats).forEach(([subKey, items]) => {
                if (!items || typeof items !== 'object') return;
                Object.entries(items).forEach(([itemKey, field]) => {
                    if (!isMeaningfulField(field)) return;
                    cardHasItems = true;
                    anyShown = true;

                    const label = prettifyKey(itemKey);

                    // чип с привязкой к таблице Purpose
                    const chip = createChip(
                        label,
                        field.value,
                        field.supporting_citation || '',
                        {domain: 'purpose', fieldId: itemKey}
                    );
                    chipsWrap.appendChild(chip);

                    const band = purposeRiskMap[itemKey];
                    const rank = bandRank(band);
                    if (rank > maxRank) {
                        maxRank = rank;
                        maxBand = band;
                    }
                });
            });

            if (cardHasItems) {
                // цвет рамки по максимальному риску
                if (maxRank > 0) {
                    const gClass = groupClassForBand(maxBand);
                    if (gClass) card.classList.add(gClass);
                } else {
                    card.classList.add('group-border-weak');
                }

                card.appendChild(chipsWrap);
                groupsEl.appendChild(card);
            }
        });

        if (!anyShown) {
            clearGroupsWithEmptyState(
                'No explicit purposes found',
                'All detected purpose fields are unknown or missing'
            );
        }
    }

    function renderSharing(dataShare, dataLocation) {
        groupsEl.innerHTML = '';

        let anythingShown = false;

        // === БЛОК 1: С КЕМ ШАРЯТ ДАННЫЕ (summary → чекбоксы) ===
        if (dataShare && dataShare.summary && typeof dataShare.summary === 'object') {
            const summary = dataShare.summary;

            const partners = [
                {key: 'affiliates', label: 'Affiliates'},
                {key: 'employees', label: 'Employees'},
                {key: 'third_parties_named', label: 'Named third parties'},
                {key: 'third_parties_unnamed', label: 'Unspecified third parties'}
            ];

            const card = document.createElement('div');
            card.className = 'group group-border-weak';

            const title = document.createElement('div');
            title.className = 'group-title';
            title.textContent = 'Data sharing partners';
            card.appendChild(title);

            const table = document.createElement('div');
            table.className = 'sharing-table';

            partners.forEach(p => {
                const field = summary[p.key];

                // Если поле есть — берём value, иначе считаем "unknown/absent" → крестик
                let v = field ? field.value : 'unknown';
                let lower = (v === null || v === undefined) ? 'unknown' : String(v).toLowerCase().trim();

                const isShared = (lower === 'present' || lower === 'partial' || lower === 'yes' || lower === 'true');

                const row = document.createElement('div');
                row.className = 'sharing-row';

                const labelEl = document.createElement('div');
                labelEl.className = 'sharing-label';
                labelEl.textContent = p.label;

                const statusEl = document.createElement('div');
                statusEl.className = 'sharing-status ' + (isShared ? 'sharing-status-yes' : 'sharing-status-no');
                statusEl.textContent = isShared ? '✅' : '❌';

                // если есть supporting_citation — вешаем тултип на всю строку
                if (field && field.supporting_citation) {
                    attachTooltipHandlers(row, field.supporting_citation);
                }

                row.appendChild(labelEl);
                row.appendChild(statusEl);
                table.appendChild(row);
            });

            card.appendChild(table);
            groupsEl.appendChild(card);
            anythingShown = true;
        }

        // === БЛОК 2: ЛОКАЦИЯ ДАННЫХ ===
        if (dataLocation && dataLocation.jurisdictions && isMeaningfulField(dataLocation.jurisdictions)) {
            const j = dataLocation.jurisdictions;
            let v = j.supporting_citation;

            let displayText = '';
            let emoji = '';

            if (Array.isArray(v)) {
                if (v.length === 0) {
                    displayText = 'Not specified';
                } else {
                    displayText = v.join(', ');
                }
            } else if (v !== null && v !== undefined) {
                const s = String(v).trim();
                if (/global|worldwide/i.test(s)) {
                    displayText = 'Worldwide';
                    emoji = ' 🌐';
                } else {
                    displayText = s;
                }
            } else {
                displayText = 'Not specified';
            }

            const card = document.createElement('div');
            card.className = 'group group-border-weak';

            const title = document.createElement('div');
            title.className = 'group-title';
            title.textContent = 'Data location';

            const table = document.createElement('div');
            table.className = 'sharing-table';

            const row = document.createElement('div');
            row.className = 'sharing-row';

            const labelEl = document.createElement('div');
            labelEl.className = 'sharing-label';
            labelEl.textContent = 'Jurisdictions';

            const statusEl = document.createElement('div');
            statusEl.className = 'sharing-status';
            statusEl.textContent = displayText + emoji;

            if (j.supporting_citation) {
                attachTooltipHandlers(row, j.supporting_citation);
            }

            row.appendChild(labelEl);
            row.appendChild(statusEl);
            table.appendChild(row);

            card.appendChild(title);
            card.appendChild(table);
            groupsEl.appendChild(card);
            anythingShown = true;
        }

        if (!anythingShown) {
            clearGroupsWithEmptyState(
                'No sharing or location info',
                'We found no structured information about sharing partners or data location'
            );
        }
    }

    function renderAITraining(useAI) {
        groupsEl.innerHTML = '';

        if (!useAI || typeof useAI !== 'object') {
            clearGroupsWithEmptyState(
                'No AI training info',
                'We did not detect any statements about using data for training AI models'
            );
            return;
        }

        let anythingShown = false;

        // Нормализация булевых/тристейт значений
        const normalizeState = (val) => {
            if (val === null || val === undefined) return 'unknown';
            const s = String(val).toLowerCase().trim();
            if (['true', 'yes', 'present'].includes(s)) return 'yes';
            if (['false', 'no', 'absent'].includes(s)) return 'no';
            if (s === 'partial') return 'partial';
            return 'unknown';
        };

        const iconForState = (state, treatPartialAsYes = false) => {
            if (state === 'yes') return '✅';
            if (state === 'partial') return treatPartialAsYes ? '✅' : '❓';
            if (state === 'no') return '❌';
            return '❓';
        };

        // === КАРТОЧКА 1: флаги UseToTrain и UserOptOut ===
        const flagsCard = document.createElement('div');
        flagsCard.className = 'group group-border-weak';

        const flagsTitle = document.createElement('div');
        flagsTitle.className = 'group-title';
        flagsTitle.textContent = 'Use of data for AI training';
        flagsCard.appendChild(flagsTitle);

        const table = document.createElement('div');
        table.className = 'sharing-table';

        // UseToTrain (used_for_training)
        if (useAI.used_for_training) {
            const st = normalizeState(useAI.used_for_training.value);
            const row = document.createElement('div');
            row.className = 'sharing-row';

            const labelEl = document.createElement('div');
            labelEl.className = 'sharing-label';
            labelEl.textContent = 'Use to train models';

            const statusEl = document.createElement('div');
            statusEl.className = 'sharing-status ' + (st === 'yes' ? 'sharing-status-yes'
                : st === 'no' ? 'sharing-status-no'
                    : '');
            statusEl.textContent = iconForState(st, false);

            if (useAI.used_for_training.supporting_citation) {
                attachTooltipHandlers(row, useAI.used_for_training.supporting_citation);
            }

            row.appendChild(labelEl);
            row.appendChild(statusEl);
            table.appendChild(row);
            anythingShown = true;
        }

        // UserOptOut (user_opt_out)
        if (useAI.user_opt_out) {
            const st = normalizeState(useAI.user_opt_out.value);
            const row = document.createElement('div');
            row.className = 'sharing-row';

            const labelEl = document.createElement('div');
            labelEl.className = 'sharing-label';
            labelEl.textContent = 'User opt-out';

            const statusEl = document.createElement('div');
            statusEl.className = 'sharing-status ' + (
                (st === 'yes' || st === 'partial') ? 'sharing-status-yes'
                    : st === 'no' ? 'sharing-status-no'
                        : ''
            );
            // по твоему описанию:
            // unknown → ❓, true/partial → ✅, false → ❌
            statusEl.textContent = iconForState(st, true);

            if (useAI.user_opt_out.supporting_citation) {
                attachTooltipHandlers(row, useAI.user_opt_out.supporting_citation);
            }

            row.appendChild(labelEl);
            row.appendChild(statusEl);
            table.appendChild(row);
            anythingShown = true;
        }

        if (table.children.length > 0) {
            flagsCard.appendChild(table);
            groupsEl.appendChild(flagsCard);
        }

        // === КАРТОЧКА 2: категории данных для обучения ===
        if (useAI.data_categories && isMeaningfulField(useAI.data_categories)) {
            const field = useAI.data_categories;
            let vals = [];

            if (Array.isArray(field.value)) {
                vals = field.value;
            } else if (field.value !== null && field.value !== undefined) {
                // fallback — если пришла строка, режем по запятым/пробелам
                vals = String(field.value)
                    .split(/[,\s]+/)
                    .map(v => v.trim())
                    .filter(v => v.length > 0);
            }

            if (vals.length > 0) {
                const card = document.createElement('div');
                card.className = 'group group-border-weak';

                const title = document.createElement('div');
                title.className = 'group-title';
                title.textContent = 'Training data categories';
                card.appendChild(title);

                const chipsWrap = document.createElement('div');
                chipsWrap.className = 'chips';

                vals.forEach(v => {
                    // предполагаем, что v уже совпадает с field_id в data_type_risk_weights.csv
                    const fieldId = String(v).trim();
                    const label = prettifyKey(fieldId);

                    const chip = createChip(
                        label,
                        'present',                        // базовое состояние чипа
                        field.supporting_citation || '',  // тултип
                        {
                            domain: 'data_type',          // скажем createChip, какую таблицу использовать
                            fieldId: fieldId              // ключ для dataTypeRiskMap[fieldId]
                        }
                    );

                    chipsWrap.appendChild(chip);
                });

                card.appendChild(chipsWrap);
                groupsEl.appendChild(card);
                anythingShown = true;
            }
        }

        // === КАРТОЧКА 3: Streaming data categories (OpenAI) ===
        if (useAI.streaming_data_categories) {
            const field = useAI.streaming_data_categories;
            let values = [];

            if (Array.isArray(field.value)) {
                values = field.value;
            } else if (field.value && typeof field.value === 'object') {
                values = Object.entries(field.value)
                    .filter(([, f]) => isDataCollectedField(f))
                    .map(([fieldId, f]) => ({
                        fieldId,
                        citation: f.supporting_citation || ''
                    }));
            } else if (field.value !== null && field.value !== undefined) {
                values = String(field.value)
                    .split(/[;,]+/)
                    .map(v => v.trim())
                    .filter(Boolean);
            }

            if (values.length > 0) {
                const card = document.createElement('div');
                card.className = 'group'; // без окраски рамки

                const title = document.createElement('div');
                title.className = 'group-title';
                title.textContent = 'Streaming data categories (OpenAI)';
                card.appendChild(title);

                const chipsWrap = document.createElement('div');
                chipsWrap.className = 'chips';

                values.forEach(v => {
                    let fieldId, label, citation;

                    if (typeof v === 'object' && v.fieldId) {
                        fieldId = v.fieldId;
                        label = prettifyKey(v.fieldId);
                        citation = v.citation || field.supporting_citation || '';
                    } else {
                        fieldId = String(v);
                        label = prettifyKey(v);
                        citation = field.supporting_citation || '';
                    }

                    const chip = createChip(
                        label,
                        'present',
                        citation,
                        {domain: 'data_type', fieldId}
                    );
                    chipsWrap.appendChild(chip);
                });

                card.appendChild(chipsWrap);
                groupsEl.appendChild(card);
                anythingShown = true;
            }
        }

        if (!anythingShown) {
            clearGroupsWithEmptyState(
                'No AI training details',
                'We did not find concrete statements about AI training or training data categories'
            );
        }
    }

    function renderSecurityAndBreach(sec, breach) {
        groupsEl.innerHTML = '';

        let anything = false;

        // Нормализация булевых значений
        const normalizeBoolState = (val) => {
            if (val === null || val === undefined) return 'unknown';
            const s = String(val).toLowerCase().trim();
            if (['true', 'yes', 'present'].includes(s)) return 'yes';
            if (['false', 'no', 'absent'].includes(s)) return 'no';
            return 'text'; // произвольный текст (алгоритм, версия и т.п.)
        };

        const iconForBool = (state) => {
            if (state === 'yes') return '✅';
            if (state === 'no') return '❌';
            if (state === 'unknown') return '❓';
            return '';
        };

        /* ========== SECURITY ========== */
        if (sec && typeof sec === 'object') {
            const card = document.createElement('div');
            card.className = 'group group-border-weak';

            const title = document.createElement('div');
            title.className = 'group-title';
            title.textContent = 'Security controls';
            card.appendChild(title);

            const table = document.createElement('div');
            table.className = 'sharing-table';

            // 1) sec.controls (общие меры)
            if (sec.controls && sec.controls.value !== null && sec.controls.value !== undefined) {
                const raw = sec.controls.value;
                const norm = normalizeBoolState(raw);

                // требование: список мер, которые НЕ unknown
                if (String(raw).toLowerCase().trim() !== 'unknown') {
                    const row = document.createElement('div');
                    row.className = 'sharing-row';

                    const labelEl = document.createElement('div');
                    labelEl.className = 'sharing-label';
                    labelEl.textContent = 'General security controls';

                    const statusEl = document.createElement('div');
                    statusEl.className = 'sharing-status';

                    if (norm === 'yes' || norm === 'no' || norm === 'unknown') {
                        statusEl.textContent = iconForBool(norm);
                    } else {
                        // текстовое значение (если вдруг будет)
                        statusEl.textContent = String(raw);
                    }

                    if (sec.controls.supporting_citation) {
                        attachTooltipHandlers(row, sec.controls.supporting_citation);
                    }

                    row.appendChild(labelEl);
                    row.appendChild(statusEl);
                    table.appendChild(row);
                }
            }

            // 2) crypto.* (конкретные меры шифрования)
            if (sec.crypto && typeof sec.crypto === 'object') {
                const c = sec.crypto;

                const cryptoKeys = [
                    'encryption_at_rest',
                    'encryption_in_transit',
                    'tls_version',
                    'in_transit_protocol',
                    'at_rest_algorithm_family',
                    'at_rest_algorithm_detail'
                ];

                cryptoKeys.forEach(key => {
                    const field = c[key];
                    if (!field) return;
                    const raw = field.value;

                    // пропускаем полностью отсутствующие/пустые
                    if (raw === null || raw === undefined) return;

                    // явно не показываем "unknown"
                    if (String(raw).toLowerCase().trim() === 'unknown') return;

                    const norm = normalizeBoolState(raw);

                    const row = document.createElement('div');
                    row.className = 'sharing-row';

                    const labelEl = document.createElement('div');
                    labelEl.className = 'sharing-label';
                    labelEl.textContent = prettifyKey(key);

                    const statusEl = document.createElement('div');
                    statusEl.className = 'sharing-status';

                    if (norm === 'yes' || norm === 'no' || norm === 'unknown') {
                        statusEl.textContent = iconForBool(norm);
                    } else {
                        statusEl.textContent = String(raw);
                    }

                    if (field.supporting_citation) {
                        attachTooltipHandlers(row, field.supporting_citation);
                    }

                    row.appendChild(labelEl);
                    row.appendChild(statusEl);
                    table.appendChild(row);
                });
            }

            if (table.children.length > 0) {
                card.appendChild(table);
                groupsEl.appendChild(card);
                anything = true;
            }
        }

        /* ========== BREACH NOTIFICATION ========== */
        if (breach && typeof breach === 'object') {
            const card = document.createElement('div');
            card.className = 'group group-border-weak';

            const title = document.createElement('div');
            title.className = 'group-title';
            title.textContent = 'Breach notification';
            card.appendChild(title);

            const table = document.createElement('div');
            table.className = 'sharing-table';

            Object.entries(breach).forEach(([key, field]) => {
                if (!field) return;

                const raw = field.value;

                // правило для BreachNotification:
                // null/undefined/unknown/0 без цитаты → крестик
                let state = 'yes';
                if (
                    raw === null ||
                    raw === undefined ||
                    String(raw).toLowerCase().trim() === 'unknown' ||
                    (typeof raw === 'number' && raw === 0 && !field.supporting_citation)
                ) {
                    state = 'no';
                }

                const row = document.createElement('div');
                row.className = 'sharing-row';

                const labelEl = document.createElement('div');
                labelEl.className = 'sharing-label';
                labelEl.textContent = prettifyKey(key);

                const statusEl = document.createElement('div');
                statusEl.className = 'sharing-status ' +
                    (state === 'yes' ? 'sharing-status-yes' : 'sharing-status-no');

                // "список с значениями": показываем и иконку, и значение, если оно есть
                const valuePart = (raw !== null && raw !== undefined && String(raw).toLowerCase().trim() !== 'unknown')
                    ? ` ${String(raw)}`
                    : '';

                statusEl.textContent = `${iconForBool(state)}${valuePart}`;

                if (field.supporting_citation) {
                    attachTooltipHandlers(row, field.supporting_citation);
                }

                row.appendChild(labelEl);
                row.appendChild(statusEl);
                table.appendChild(row);
            });

            if (table.children.length > 0) {
                card.appendChild(table);
                groupsEl.appendChild(card);
                anything = true;
            }
        }

        if (!anything) {
            clearGroupsWithEmptyState(
                'No security / breach info',
                'We did not find concrete security measures or breach notification details'
            );
        }
    }

    function renderRetention(overall) {
        groupsEl.innerHTML = '';

        if (!overall || typeof overall !== 'object') {
            clearGroupsWithEmptyState(
                'No retention policy',
                'We did not detect an overall retention statement in this policy'
            );
            return;
        }

        const card = document.createElement('div');
        card.className = 'group group-border-weak';

        const title = document.createElement('div');
        title.className = 'group-title';
        title.textContent = 'Data retention (overall policy)';
        card.appendChild(title);

        // 1) Комментарий – просто текстом
        if (overall.comment && isMeaningfulField(overall.comment)) {
            const p = document.createElement('p');
            p.style.fontSize = '13px';
            p.style.margin = '0 0 10px';
            p.textContent = overall.comment.value;

            if (overall.comment.supporting_citation) {
                attachTooltipHandlers(p, overall.comment.supporting_citation);
            }

            card.appendChild(p);
        }

        // 2) Список FixedPeriodYears / MaximumPeriodYears / StatementType –
        // просто значения (в списке)
        const list = document.createElement('div');
        list.className = 'sharing-table'; // используем тот же стиль, что в DataShare/AI/Security

        const addRow = (label, field) => {
            if (!field || !isMeaningfulField(field)) return;

            const row = document.createElement('div');
            row.className = 'sharing-row';

            const labelEl = document.createElement('div');
            labelEl.className = 'sharing-label';
            labelEl.textContent = label;

            const valueEl = document.createElement('div');
            valueEl.className = 'sharing-status';
            valueEl.textContent = String(field.value);

            if (field.supporting_citation) {
                attachTooltipHandlers(row, field.supporting_citation);
            }

            row.appendChild(labelEl);
            row.appendChild(valueEl);
            list.appendChild(row);
        };

        addRow('Fixed period (years)', overall.fixed_period_years);
        addRow('Maximum period (years)', overall.maximum_period_years);
        addRow('Statement type', overall.statement_type);

        // Если есть либо комментарий, либо список – показываем карточку
        if (!overall.comment && list.children.length === 0) {
            clearGroupsWithEmptyState(
                'No retention policy',
                'We did not detect fixed or maximum retention periods in this policy'
            );
            return;
        }

        if (list.children.length > 0) {
            card.appendChild(list);
        }

        groupsEl.appendChild(card);
    }

    function renderRights(rights) {
        groupsEl.innerHTML = '';

        if (!rights || typeof rights !== 'object') {
            clearGroupsWithEmptyState(
                'No rights information',
                'We did not detect any user rights in this policy'
            );
            return;
        }

        const card = document.createElement('div');
        card.className = 'group group-border-weak';

        const title = document.createElement('div');
        title.className = 'group-title';
        title.textContent = 'User rights';
        card.appendChild(title);

        const table = document.createElement('div');
        table.className = 'sharing-table';

        const iconForRights = (val) => {
            if (!val) return '❓';
            const v = String(val).toLowerCase().trim();
            if (v === 'yes') return '✅';
            if (v === 'no') return '❌';
            if (v === 'unknown') return '❓';
            if (v === 'partial') return 'partial';
            return '❓';
        };

        Object.entries(rights).forEach(([key, field]) => {
            if (!field) return;

            const row = document.createElement('div');
            row.className = 'sharing-row';

            const labelEl = document.createElement('div');
            labelEl.className = 'sharing-label';
            labelEl.textContent = prettifyKey(key);

            const value = iconForRights(field.value);

            const valueEl = document.createElement('div');
            valueEl.className = 'sharing-status';

            if (value === 'partial') {
                valueEl.innerHTML = `<span style="color:#facc15;font-weight:600">partial</span>`;
            } else {
                valueEl.textContent = value;
            }

            if (field.supporting_citation) {
                attachTooltipHandlers(row, field.supporting_citation);
            }

            row.appendChild(labelEl);
            row.appendChild(valueEl);
            table.appendChild(row);
        });

        card.appendChild(table);
        groupsEl.appendChild(card);
    }

    function renderDarkPatterns(dp) {
        groupsEl.innerHTML = '';

        if (!dp || typeof dp !== 'object') {
            clearGroupsWithEmptyState(
                'No dark pattern info',
                'We did not detect dark pattern information'
            );
            return;
        }

        const card = document.createElement('div');
        card.className = 'group group-border-weak';

        const title = document.createElement('div');
        title.className = 'group-title';
        title.textContent = 'Dark patterns';
        card.appendChild(title);

        const table = document.createElement('div');
        table.className = 'sharing-table';

        const iconForDP = (value) => {
            if (!value) return '❓';
            const v = String(value).toLowerCase().trim();

            // по твоим правилам:
            if (v === 'absent') return '❗';                 // красный warning
            if (v === 'present') return '✅';                // зелёная галочка
            if (v === 'unknown') return '✅';                // тоже зелёная галочка
            return '❓';
        };

        Object.entries(dp).forEach(([key, field]) => {
            if (!field) return;

            const row = document.createElement('div');
            row.className = 'sharing-row';

            const labelEl = document.createElement('div');
            labelEl.className = 'sharing-label';
            labelEl.textContent = prettifyKey(key);

            const valueEl = document.createElement('div');
            valueEl.className = 'sharing-status';
            valueEl.textContent = iconForDP(field.value);

            if (String(field.value).toLowerCase().trim() === 'absent') {
                valueEl.style.color = '#ef4444'; // красный
            }

            if (field.supporting_citation) {
                attachTooltipHandlers(row, field.supporting_citation);
            }

            row.appendChild(labelEl);
            row.appendChild(valueEl);
            table.appendChild(row);
        });

        card.appendChild(table);
        groupsEl.appendChild(card);
    }

    /* ===== TOP VIEW SWITCHER ===== */
    const topSwitcher = document.getElementById('topSwitcher');
    const dashboardRightView = document.getElementById('dashboardRightView');
    const myAppsRightView = document.getElementById('myAppsRightView');

    let currentTopView = 'myapps'; // 'dashboard' | 'myapps' - start with My Apps

    // Risk band colors for circle packing (same as chips/cards)
    function getRiskBandColor(band) {
        const b = (band || '').toUpperCase();
        if (b === 'HIGH') return '#dc2626';      // coral-deep
        if (b === 'MED' || b === 'MEDIUM') return '#f59e0b'; // amber-core
        return '#64748b';                         // slate-core (low or unknown)
    }

    function switchTopView(view) {
        if (view === currentTopView) return;
        
        const prevView = currentTopView;
        currentTopView = view;
        
        // Determine animation direction: dashboard is "left", myapps is "right"
        const goingRight = view === 'myapps';
        const exitDirection = goingRight ? 'view-exit-left' : 'view-exit-right';
        const enterDirection = goingRight ? 'view-enter-right' : 'view-enter-left';

        document.querySelectorAll('.top-switcher-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.view === view);
        });
        
        const outgoingView = prevView === 'dashboard' ? dashboardRightView : myAppsRightView;
        const incomingView = view === 'dashboard' ? dashboardRightView : myAppsRightView;
        
        // Animate out the current view
        outgoingView.classList.add(exitDirection);
        
        // After exit animation, switch views and animate in
        setTimeout(() => {
            outgoingView.classList.remove('active', exitDirection, 'view-exit-left', 'view-exit-right');
            
            // Prepare incoming view with enter state
            incomingView.classList.add(enterDirection);
            incomingView.classList.add('active');
            
            // Render dashboard widgets if switching to dashboard
            if (view === 'dashboard') {
                renderDashboardWidgets();
            }
            
            // Force reflow to ensure the enter class is applied before removing
            void incomingView.offsetWidth;
            
            // Remove enter class to trigger animation
            requestAnimationFrame(() => {
                incomingView.classList.remove(enterDirection, 'view-enter-left', 'view-enter-right');
            });
        }, 150);
    }

    topSwitcher.addEventListener('click', (e) => {
        const btn = e.target.closest('.top-switcher-btn');
        if (!btn) return;
        switchTopView(btn.dataset.view);
    });

    /* ===== DASHBOARD WIDGETS ===== */

    function renderDashboardWidgets() {
        renderCirclePackingWidget();
        renderAvgScoreWidget();
        renderCriticalAppsWidget();
        renderRoseHistogramWidget();
        renderRetentionWidget();
        renderAITrainingWidget();
    }

    // Collect all data subcategories from selected apps (matching the rectangles in "Data collected")
    function collectDataCategoriesFromApps() {
        // subKey -> { count: number, maxRiskBand: string, apps: [{appId, appData, riskBand}] }
        const subCategoryData = new Map();

        selectedApps.forEach((appData, appId) => {
            const privacy = appData.privacy;
            if (!privacy) return;

            const dataType = privacy.DataType || privacy.DataTypeInfo;
            if (!dataType || typeof dataType !== 'object') return;

            // Track which subcategories this app has (to count each app only once per subcat)
            const appSubcats = new Map(); // subKey -> { rank, band }

            Object.entries(dataType).forEach(([catKey, subcats]) => {
                if (!subcats || typeof subcats !== 'object') return;

                Object.entries(subcats).forEach(([subKey, items]) => {
                    if (!items || typeof items !== 'object') return;

                    let subHasPresent = false;
                    let maxRankInSub = 0;
                    let maxBandInSub = null;
                    const collectedItems = []; // Track which specific items are collected

                    Object.entries(items).forEach(([itemKey, field]) => {
                        if (isDataCollectedField(field)) {
                            subHasPresent = true;
                            collectedItems.push(prettifyKey(itemKey));
                            // Get risk band from dataTypeRiskMap
                            const band = dataTypeRiskMap[itemKey];
                            const rank = bandRank(band);
                            if (rank > maxRankInSub) {
                                maxRankInSub = rank;
                                maxBandInSub = band;
                            }
                        }
                    });

                    if (subHasPresent) {
                        // Track this subcat for this app (merge data items if already exists)
                        if (!appSubcats.has(subKey)) {
                            appSubcats.set(subKey, { rank: maxRankInSub, band: maxBandInSub, dataItems: collectedItems });
                        } else {
                            const existing = appSubcats.get(subKey);
                            if (maxRankInSub > existing.rank) {
                                existing.rank = maxRankInSub;
                                existing.band = maxBandInSub;
                            }
                            // Merge data items
                            collectedItems.forEach(item => {
                                if (!existing.dataItems.includes(item)) {
                                    existing.dataItems.push(item);
                                }
                            });
                        }
                    }
                });
            });

            // Add this app's subcategories to the global map
            appSubcats.forEach(({ rank, band, dataItems }, subKey) => {
                if (!subCategoryData.has(subKey)) {
                    subCategoryData.set(subKey, { count: 0, maxRiskRank: 0, maxRiskBand: null, apps: [] });
                }
                const entry = subCategoryData.get(subKey);
                entry.count++;
                entry.apps.push({ appId, appData, riskBand: band, dataItems: dataItems || [] });
                // Keep track of the max risk band across all apps
                if (rank > entry.maxRiskRank) {
                    entry.maxRiskRank = rank;
                    entry.maxRiskBand = band;
                }
            });
        });

        return subCategoryData;
    }

    // Category modal references
    const categoryModalOverlay = document.getElementById('categoryModalOverlay');
    const categoryModal = document.getElementById('categoryModal');
    const categoryModalIcon = document.getElementById('categoryModalIcon');
    const categoryModalTitle = document.getElementById('categoryModalTitle');
    const categoryModalSubtitle = document.getElementById('categoryModalSubtitle');
    const categoryModalClose = document.getElementById('categoryModalClose');
    const categoryModalApps = document.getElementById('categoryModalApps');

    function openCategoryModal(categoryData) {
        const { name, riskBand, apps } = categoryData;
        
        // Set modal content
        categoryModalTitle.textContent = name;
        categoryModalSubtitle.textContent = `${apps.length} app${apps.length > 1 ? 's' : ''} collect this data`;
        
        // Icon color based on risk
        const color = getRiskBandColor(riskBand);
        categoryModalIcon.style.background = color;
        categoryModalIcon.innerHTML = '📊';
        
        // Build apps list
        categoryModalApps.innerHTML = '';
        
        // Sort apps by risk score descending
        const sortedApps = [...apps].sort((a, b) => {
            const scoreA = a.appData.ranking?.overall_privacy_risk ?? 0;
            const scoreB = b.appData.ranking?.overall_privacy_risk ?? 0;
            return scoreB - scoreA;
        });
        
        sortedApps.forEach(({ appId, appData, riskBand: appRisk, dataItems }) => {
            const item = document.createElement('div');
            item.className = 'category-modal-app';
            
            const iconUrl = appData.logo_url;
            const appName = appData.name || appId;
            const score = appData.ranking?.overall_privacy_risk;
            
            // Risk class based on overall app score: >7=high, 4-7=med, <4=low
            let riskClass = 'low';
            let riskLabel = 'low';
            if (score !== undefined) {
                if (score > 7) {
                    riskClass = 'high';
                    riskLabel = 'high';
                } else if (score >= 4) {
                    riskClass = 'med';
                    riskLabel = 'medium';
                }
            }
            
            // Build data chips HTML
            const dataChipsHtml = (dataItems && dataItems.length > 0) 
                ? `<div class="category-modal-app-data">
                    ${dataItems.map(item => `<span class="category-modal-data-chip">${escapeHtml(item)}</span>`).join('')}
                   </div>`
                : '';
            
            item.innerHTML = `
                <div class="category-modal-app-icon">
                    ${iconUrl ? `<img src="${iconUrl}" alt="">` : '<span style="font-size:20px;opacity:.6;">📱</span>'}
                </div>
                <div class="category-modal-app-info">
                    <div class="category-modal-app-name">${escapeHtml(appName)}</div>
                    <div class="category-modal-app-score">
                        ${score !== undefined ? `Risk: ${score.toFixed(1)}/10` : 'No score'}
                        <span class="category-modal-risk-badge ${riskClass}">${riskLabel}</span>
                    </div>
                    ${dataChipsHtml}
                </div>
                <div class="category-modal-app-arrow">→</div>
            `;
            
            item.addEventListener('click', () => {
                closeCategoryModal();
                switchTopView('myapps');
                selectApp(appId);
            });
            
            categoryModalApps.appendChild(item);
        });
        
        // Show modal
        categoryModalOverlay.classList.add('active');
    }

    function closeCategoryModal() {
        categoryModalOverlay.classList.remove('active');
    }

    // Modal close handlers
    if (categoryModalClose) {
        categoryModalClose.addEventListener('click', closeCategoryModal);
    }
    if (categoryModalOverlay) {
        categoryModalOverlay.addEventListener('click', (e) => {
            if (e.target === categoryModalOverlay) closeCategoryModal();
        });
    }

    function renderCirclePackingWidget() {
        const widgetContent = document.querySelector('#widgetCirclePacking .widget-content');
        if (!widgetContent) return;

        const categoryCount = collectDataCategoriesFromApps();

        if (categoryCount.size === 0) {
            widgetContent.innerHTML = '<div class="widget-empty">Add apps to see data categories</div>';
            return;
        }

        // Ensure SVG exists
        let svgEl = widgetContent.querySelector('#circlePackingSvg');
        if (!svgEl) {
            widgetContent.innerHTML = '<svg class="circle-packing-svg" id="circlePackingSvg"></svg>';
            svgEl = widgetContent.querySelector('#circlePackingSvg');
        }

        const svg = d3.select(svgEl);
        svg.selectAll('*').remove();

        // Add gradient definitions for modern look
        const defs = svg.append('defs');
        
        // Build hierarchy for D3 pack - using subcategories with risk bands and apps
        const children = Array.from(categoryCount.entries()).map(([subKey, data]) => ({
            name: prettifyKey(subKey),
            key: subKey,
            value: data.count,
            riskBand: data.maxRiskBand,
            apps: data.apps
        }));

        const hierarchy = d3.hierarchy({ children })
            .sum(d => d.value || 0);

        const rect = widgetContent.getBoundingClientRect();
        const width = rect.width || 300;
        const height = rect.height || 300;
        const size = Math.min(width, height);

        svg.attr('viewBox', `0 0 ${size} ${size}`);

        const pack = d3.pack()
            .size([size - 12, size - 12])
            .padding(6);

        const root = pack(hierarchy);

        // Create gradient for each node
        root.leaves().forEach((d, i) => {
            const baseColor = getRiskBandColor(d.data.riskBand);
            const grad = defs.append('radialGradient')
                .attr('id', `circleGrad${i}`)
                .attr('cx', '30%')
                .attr('cy', '30%')
                .attr('r', '70%');
            
            grad.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', d3.color(baseColor).brighter(0.5));
            
            grad.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', d3.color(baseColor).darker(0.3));
        });

        // Create category groups
        const groups = svg.selectAll('g.category-group')
            .data(root.leaves())
            .enter()
            .append('g')
            .attr('class', 'category-group')
            .attr('transform', d => `translate(${d.x + 6}, ${d.y + 6})`)
            .on('click', function(event, d) {
                openCategoryModal(d.data);
            });

        // Invisible hit area (larger) to prevent hover flicker during scale
        groups.append('circle')
            .attr('class', 'hit-area')
            .attr('r', d => d.r * 1.2);

        // Visual group that scales on hover
        const visualGroups = groups.append('g')
            .attr('class', 'category-visual');

        // Add hover animations via D3 (SVG-friendly scaling from center)
        groups
            .on('mouseenter', function(event, d) {
                // Bring this group to front
                this.parentNode.appendChild(this);
                
                const visual = d3.select(this).select('.category-visual');
                visual.transition()
                    .duration(280)
                    .ease(d3.easeCubicOut)
                    .attr('transform', 'scale(1.25)');
                
                // Move text to top
                d3.select(this).select('.text-group')
                    .transition()
                    .duration(250)
                    .ease(d3.easeCubicOut)
                    .attr('transform', `translate(0, ${-d.r * 0.35})`);
                
                // Hide count text
                d3.select(this).select('.category-count')
                    .transition()
                    .duration(150)
                    .style('opacity', 0);
                
                // Show icons
                d3.select(this).select('.app-icons-group')
                    .transition()
                    .duration(300)
                    .delay(80)
                    .style('opacity', 1);
            })
            .on('mouseleave', function(event, d) {
                const visual = d3.select(this).select('.category-visual');
                visual.transition()
                    .duration(220)
                    .ease(d3.easeCubicIn)
                    .attr('transform', 'scale(1)');
                
                // Move text back to center
                d3.select(this).select('.text-group')
                    .transition()
                    .duration(200)
                    .ease(d3.easeCubicIn)
                    .attr('transform', 'translate(0, 0)');
                
                // Show count text
                d3.select(this).select('.category-count')
                    .transition()
                    .duration(200)
                    .delay(100)
                    .style('opacity', 1);
                
                // Hide icons
                d3.select(this).select('.app-icons-group')
                    .transition()
                    .duration(150)
                    .style('opacity', 0);
            });

        // Main category circle with gradient
        visualGroups.append('circle')
            .attr('class', 'category-circle')
            .attr('r', d => d.r)
            .attr('fill', (d, i) => `url(#circleGrad${i})`);

        // Helper function to wrap text into multiple lines
        function wrapText(text, maxWidth, fontSize) {
            const words = text.split(/\s+/);
            const lines = [];
            let currentLine = '';
            const charWidth = fontSize * 0.55; // approximate char width
            
            words.forEach(word => {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                if (testLine.length * charWidth <= maxWidth) {
                    currentLine = testLine;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            });
            if (currentLine) lines.push(currentLine);
            
            return lines;
        }

        // Category label - centered, full text with multiple lines if needed
        visualGroups.filter(d => d.r > 15).each(function(d) {
            const g = d3.select(this);
            const r = d.r;
            const name = d.data.name;
            
            // Create text group that can be animated
            const textGroup = g.append('g')
                .attr('class', 'text-group');
            
            // Calculate font size based on circle size and text length
            const maxWidth = r * 1.6;
            let fontSize = Math.min(r * 0.22, 11);
            fontSize = Math.max(fontSize, 6);
            
            // Check if text fits in one line
            const charWidth = fontSize * 0.55;
            const textWidth = name.length * charWidth;
            
            let lines;
            if (textWidth <= maxWidth) {
                lines = [name];
            } else {
                // Try wrapping, reduce font if too many lines
                lines = wrapText(name, maxWidth, fontSize);
                if (lines.length > 2) {
                    fontSize = Math.max(fontSize * 0.8, 5);
                    lines = wrapText(name, maxWidth, fontSize);
                }
                // Limit to 3 lines max
                if (lines.length > 3) {
                    lines = lines.slice(0, 3);
                    lines[2] = lines[2].slice(0, -1) + '…';
                }
            }
            
            const lineHeight = fontSize * 1.2;
            const totalHeight = lines.length * lineHeight;
            // Center text vertically in circle (slightly up to leave room for count)
            const startY = -totalHeight / 2 + lineHeight / 2 - fontSize * 0.3;
            
            lines.forEach((line, i) => {
                textGroup.append('text')
                    .attr('class', 'category-label')
                    .attr('y', startY + i * lineHeight)
                    .attr('font-size', fontSize)
                    .text(line);
            });
            
            // Count badge - below the label
            if (r > 20) {
                textGroup.append('text')
                    .attr('class', 'category-count')
                    .attr('y', startY + lines.length * lineHeight + fontSize * 0.5)
                    .attr('font-size', Math.min(r * 0.15, 8))
                    .text(`${d.data.value} app${d.data.value > 1 ? 's' : ''}`);
            }
        });

        // Add ALL app icons using circle packing (hidden by default, shown on hover)
        visualGroups.each(function(d, idx) {
            const g = d3.select(this);
            const apps = d.data.apps || [];
            const r = d.r;
            
            // Only add icons if circle is big enough
            if (r < 18 || apps.length === 0) return;
            
            // Create a group for icons (hidden by default via CSS)
            const iconsGroup = g.append('g')
                .attr('class', 'app-icons-group')
                .attr('transform', `translate(0, ${r * 0.1})`); // Shift down slightly
            
            // Use D3 pack to arrange all app icons - fill more space
            const iconAreaRadius = r * 0.75; // Larger area for icons
            const iconData = apps.map((app, i) => ({ app, id: i }));
            
            const iconHierarchy = d3.hierarchy({ children: iconData })
                .sum(() => 1);
            
            const iconPack = d3.pack()
                .size([iconAreaRadius * 2, iconAreaRadius * 1.6])
                .padding(1);
            
            const iconRoot = iconPack(iconHierarchy);
            
            iconRoot.leaves().forEach((node, i) => {
                const app = node.data.app;
                const iconRadius = Math.max(node.r - 0.5, 3);
                const cx = node.x - iconAreaRadius;
                const cy = node.y - iconAreaRadius * 0.6;
                
                // Clip path for circular icon
                const clipId = `clip-${d.data.key}-${idx}-${i}`;
                defs.append('clipPath')
                    .attr('id', clipId)
                    .append('circle')
                    .attr('cx', 0)
                    .attr('cy', 0)
                    .attr('r', iconRadius);
                
                const iconItem = iconsGroup.append('g')
                    .attr('transform', `translate(${cx}, ${cy})`);
                
                // Icon background
                iconItem.append('circle')
                    .attr('class', 'app-icon-circle')
                    .attr('r', iconRadius)
                    .attr('fill', '#0d0e10');
                
                // Icon image
                if (app.appData.logo_url) {
                    iconItem.append('image')
                        .attr('class', 'app-icon-image')
                        .attr('href', app.appData.logo_url)
                        .attr('x', -iconRadius)
                        .attr('y', -iconRadius)
                        .attr('width', iconRadius * 2)
                        .attr('height', iconRadius * 2)
                        .attr('clip-path', `url(#${clipId})`)
                        .attr('preserveAspectRatio', 'xMidYMid slice');
                } else {
                    // Fallback emoji for apps without icons
                    iconItem.append('text')
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'central')
                        .attr('font-size', iconRadius)
                        .attr('fill', 'rgba(255,255,255,0.5)')
                        .text('📱');
                }
            });
        });
    }

    function renderAvgScoreWidget() {
        const svgEl = document.getElementById('avgScoreSvg');
        const labelEl = document.getElementById('avgScoreLabel');
        if (!svgEl || !labelEl) return;

        const svg = d3.select(svgEl);
        svg.selectAll('*').remove();

        // Calculate average privacy risk from selected apps
        let totalScore = 0;
        let countWithScore = 0;

        selectedApps.forEach((appData) => {
            const ranking = appData.ranking;
            if (ranking && typeof ranking.overall_privacy_risk === 'number') {
                totalScore += ranking.overall_privacy_risk;
                countWithScore++;
            }
        });

        const avgScore = countWithScore > 0 ? totalScore / countWithScore : 0;

        if (countWithScore === 0) {
            labelEl.textContent = '— / 10';
            svg.append('text')
                .attr('x', 60)
                .attr('y', 65)
                .attr('text-anchor', 'middle')
                .attr('fill', '#6b7280')
                .attr('font-size', '12')
                .text('No data');
            return;
        }

        // Draw mini gauge
        const width = 120;
        const height = 120;
        const radius = 45;
        const innerRadius = 30;

        svg.attr('viewBox', `0 0 ${width} ${height}`);

        const g = svg.append('g')
            .attr('transform', `translate(${width/2}, ${height/2})`);

        // Background arc
        const bgArc = d3.arc()
            .innerRadius(innerRadius)
            .outerRadius(radius)
            .startAngle(0)
            .endAngle(2 * Math.PI);

        g.append('path')
            .attr('d', bgArc)
            .attr('fill', '#111318');

        // Foreground arc
        const fgArc = d3.arc()
            .innerRadius(innerRadius)
            .outerRadius(radius)
            .startAngle(0)
            .endAngle((avgScore / 10) * 2 * Math.PI);

        g.append('path')
            .attr('d', fgArc)
            .attr('fill', riskColor(avgScore));

        // Center circle
        g.append('circle')
            .attr('r', innerRadius - 6)
            .attr('fill', '#0f1115');

        // Value text
        g.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', '0.35em')
            .attr('font-size', '18')
            .attr('font-weight', '700')
            .attr('fill', '#e5e7eb')
            .text(avgScore.toFixed(1));

        labelEl.textContent = `${avgScore.toFixed(1)} / 10 (${countWithScore} apps)`;
    }

    function renderCriticalAppsWidget() {
        const grid = document.getElementById('criticalAppsGrid');
        if (!grid) return;
        grid.innerHTML = '';

        if (selectedApps.size === 0) {
            grid.innerHTML = '<div class="widget-empty">Add apps to see critical ones</div>';
            return;
        }

        // Sort apps by risk score descending
        const appsWithScore = [];
        selectedApps.forEach((appData, appId) => {
            const score = appData.ranking?.overall_privacy_risk ?? -1;
            appsWithScore.push({ appId, appData, score });
        });

        appsWithScore.sort((a, b) => b.score - a.score);

        const top8 = appsWithScore.slice(0, 8);

        if (top8.length === 0 || top8.every(a => a.score < 0)) {
            grid.innerHTML = '<div class="widget-empty">No risk scores available</div>';
            return;
        }

        top8.forEach(({ appId, appData, score }) => {
            const item = document.createElement('div');
            item.className = 'critical-app-item';
            item.title = appData.name || appId;

            const iconDiv = document.createElement('div');
            iconDiv.className = 'critical-app-icon';

            if (appData.logo_url) {
                const img = document.createElement('img');
                img.src = appData.logo_url;
                img.alt = appData.name || '';
                iconDiv.appendChild(img);
            } else {
                iconDiv.innerHTML = '<span style="font-size:22px;opacity:.6;">📱</span>';
            }

            item.appendChild(iconDiv);

            // Click to go to My Apps and select this app
            item.addEventListener('click', () => {
                switchTopView('myapps');
                selectApp(appId);
            });

            grid.appendChild(item);
        });
    }

    // Rose Modal references
    const roseModalOverlay = document.getElementById('roseModalOverlay');
    const roseModalIcon = document.getElementById('roseModalIcon');
    const roseModalTitle = document.getElementById('roseModalTitle');
    const roseModalSubtitle = document.getElementById('roseModalSubtitle');
    const roseModalClose = document.getElementById('roseModalClose');
    const roseModalApps = document.getElementById('roseModalApps');

    function openRoseModal(metricLabel, riskLevel, apps) {
        const riskLabels = { med: 'Medium Risk', high: 'High Risk' };
        const riskColors = { med: '#fbbf24', high: '#ef4444' };
        const riskEmojis = { med: '⚠️', high: '🔴' };
        
        roseModalTitle.textContent = `${metricLabel} - ${riskLabels[riskLevel]}`;
        roseModalSubtitle.textContent = `${apps.length} app${apps.length > 1 ? 's' : ''}`;
        roseModalIcon.style.background = riskColors[riskLevel];
        roseModalIcon.innerHTML = riskEmojis[riskLevel];
        
        roseModalApps.innerHTML = '';
        
        // Sort apps by score descending
        const sortedApps = [...apps].sort((a, b) => b.score - a.score);
        
        sortedApps.forEach(({ appId, appData, score }) => {
            const item = document.createElement('div');
            item.className = 'rose-modal-app';
            
            const iconUrl = appData.logo_url;
            const appName = appData.name || appId;
            
            item.innerHTML = `
                <div class="rose-modal-app-icon">
                    ${iconUrl ? `<img src="${iconUrl}" alt="">` : '<span style="font-size:20px;opacity:.6;">📱</span>'}
                </div>
                <div class="rose-modal-app-info">
                    <div class="rose-modal-app-name">${escapeHtml(appName)}</div>
                    <div class="rose-modal-app-score">
                        ${metricLabel}: ${score.toFixed(1)}/10
                    </div>
                </div>
                <div class="rose-modal-app-arrow">→</div>
            `;
            
            item.addEventListener('click', () => {
                closeRoseModal();
                switchTopView('myapps');
                selectApp(appId);
            });
            
            roseModalApps.appendChild(item);
        });
        
        roseModalOverlay.classList.add('active');
    }

    function closeRoseModal() {
        roseModalOverlay.classList.remove('active');
    }

    if (roseModalClose) {
        roseModalClose.addEventListener('click', closeRoseModal);
    }
    if (roseModalOverlay) {
        roseModalOverlay.addEventListener('click', (e) => {
            if (e.target === roseModalOverlay) closeRoseModal();
        });
    }

    // Rose Histogram Widget - shows distribution of risk metrics across all apps
    function renderRoseHistogramWidget() {
        const widgetContent = document.querySelector('#widgetRoseHistogram .widget-content');
        if (!widgetContent) return;

        if (selectedApps.size === 0) {
            widgetContent.innerHTML = '<div class="widget-empty">Add apps to see risk distribution</div>';
            return;
        }

        // Ensure SVG exists
        let svgEl = widgetContent.querySelector('#roseHistogramSvg');
        if (!svgEl) {
            widgetContent.innerHTML = '<svg class="rose-histogram-svg" id="roseHistogramSvg"></svg>';
            svgEl = widgetContent.querySelector('#roseHistogramSvg');
        }

        const svg = d3.select(svgEl);
        svg.selectAll('*').remove();

        const rect = widgetContent.getBoundingClientRect();
        const width = rect.width || 300;
        const height = rect.height || 300;
        const size = Math.min(width, height);
        const radius = size * 0.35;
        const centerX = width / 2;
        const centerY = height / 2 - 10;

        svg.attr('viewBox', `0 0 ${width} ${height}`);

        // Add gradient definitions for modern look
        const defs = svg.append('defs');
        
        // Glow filter
        const glow = defs.append('filter')
            .attr('id', 'roseGlow')
            .attr('x', '-50%')
            .attr('y', '-50%')
            .attr('width', '200%')
            .attr('height', '200%');
        glow.append('feGaussianBlur')
            .attr('stdDeviation', '3')
            .attr('result', 'coloredBlur');
        const feMerge = glow.append('feMerge');
        feMerge.append('feMergeNode').attr('in', 'coloredBlur');
        feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

        // Collect metric distributions across all apps with app references
        const metricDistributions = RADAR_METRICS.map(m => {
            const buckets = { 
                low: { count: 0, apps: [] }, 
                med: { count: 0, apps: [] }, 
                high: { count: 0, apps: [] } 
            };
            
            selectedApps.forEach((appData, appId) => {
                const value = toNumberSafe(appData.ranking?.[m.key], null);
                if (value !== null) {
                    const appInfo = { appId, appData, score: value };
                    if (value <= 3.33) {
                        buckets.low.count++;
                        buckets.low.apps.push(appInfo);
                    } else if (value <= 6.66) {
                        buckets.med.count++;
                        buckets.med.apps.push(appInfo);
                    } else {
                        buckets.high.count++;
                        buckets.high.apps.push(appInfo);
                    }
                }
            });
            
            const total = buckets.low.count + buckets.med.count + buckets.high.count;
            return { key: m.key, label: m.label, buckets, total };
        });

        const validMetrics = metricDistributions.filter(m => m.total > 0);

        if (validMetrics.length === 0) {
            widgetContent.innerHTML = '<div class="widget-empty">No risk scores available</div>';
            return;
        }

        const angleSlice = (2 * Math.PI) / validMetrics.length;
        const maxTotal = Math.max(...validMetrics.map(m => m.total));

        // Create root group
        const root = svg.append('g')
            .attr('transform', `translate(${centerX}, ${centerY})`);

        // Add subtle radial grid
        [0.33, 0.66, 1].forEach(level => {
            root.append('circle')
                .attr('r', radius * level)
                .attr('fill', 'none')
                .attr('stroke', 'rgba(255,255,255,0.06)')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '4,4');
        });

        // Risk colors - only medium and high (yellow/red palette)
        const riskColors = {
            med: '#fbbf24',   // amber/yellow
            high: '#ef4444'   // red
        };

        // Calculate max for scaling (only med + high counts)
        const maxMedHigh = Math.max(...validMetrics.map(m => m.buckets.med.count + m.buckets.high.count));

        // Draw petals for each metric as a group
        validMetrics.forEach((m, i) => {
            const startAngle = i * angleSlice - angleSlice / 2 - Math.PI / 2;
            const endAngle = startAngle + angleSlice * 0.82;
            
            // Only count med + high
            const medHighTotal = m.buckets.med.count + m.buckets.high.count;
            if (medHighTotal === 0) return; // Skip if no med/high apps
            
            const scale = medHighTotal / maxMedHigh;
            
            // Create petal group - NO transform-origin CSS, we handle scaling via D3
            const petalGroup = root.append('g')
                .attr('class', 'rose-petal-group');

            // Add label first (so we can reference it in hover handlers)
            const angle = i * angleSlice - Math.PI / 2;
            const labelRadius = radius + 24;
            const lx = Math.cos(angle) * labelRadius;
            const ly = Math.sin(angle) * labelRadius;
            
            const labelText = petalGroup.append('text')
                .attr('class', 'rose-label')
                .attr('x', lx)
                .attr('y', ly)
                .attr('text-anchor', lx < -5 ? 'end' : (lx > 5 ? 'start' : 'middle'))
                .attr('dominant-baseline', 'middle')
                .attr('font-size', 10)
                .attr('font-weight', 500)
                .attr('fill', '#9ca3af')
                .attr('opacity', 1)
                .text(m.label);

            // Store all paths in this group for scaling
            const petalPaths = [];
            
            let currentInnerRadius = 12;
            const segments = [
                { key: 'med', data: m.buckets.med },
                { key: 'high', data: m.buckets.high }
            ];

            segments.forEach((seg, segIdx) => {
                if (seg.data.count === 0) return;
                
                const segmentHeight = (seg.data.count / medHighTotal) * radius * scale;
                const outerR = currentInnerRadius + segmentHeight;
                
                const arc = d3.arc()
                    .innerRadius(currentInnerRadius)
                    .outerRadius(outerR)
                    .startAngle(startAngle + Math.PI / 2)
                    .endAngle(endAngle + Math.PI / 2)
                    .cornerRadius(4);
                
                // Create gradient for this segment
                const gradId = `roseGrad${i}_${segIdx}`;
                const grad = defs.append('linearGradient')
                    .attr('id', gradId)
                    .attr('x1', '0%')
                    .attr('y1', '0%')
                    .attr('x2', '100%')
                    .attr('y2', '100%');
                
                grad.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', d3.color(riskColors[seg.key]).brighter(0.3));
                grad.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', d3.color(riskColors[seg.key]).darker(0.2));
                
                // Create a group for this segment to hold hit area and visual petal
                const segGroup = petalGroup.append('g')
                    .attr('class', 'rose-segment-group');
                
                // Invisible hit area (slightly larger, doesn't scale)
                const hitArea = segGroup.append('path')
                    .attr('class', 'rose-hit-area')
                    .attr('d', d3.arc()
                        .innerRadius(Math.max(0, currentInnerRadius - 5))
                        .outerRadius(outerR + 10)
                        .startAngle(startAngle + Math.PI / 2)
                        .endAngle(endAngle + Math.PI / 2)
                        .cornerRadius(4)())
                    .attr('fill', 'transparent')
                    .attr('stroke', 'none')
                    .style('cursor', 'pointer');
                
                // Visible petal
                const petal = segGroup.append('path')
                    .attr('class', 'rose-petal')
                    .attr('d', arc())
                    .attr('fill', `url(#${gradId})`)
                    .attr('opacity', 0.9)
                    .attr('stroke', 'rgba(255,255,255,0.25)')
                    .attr('stroke-width', 1)
                    .style('pointer-events', 'none'); // Hit area handles events
                
                petalPaths.push({ petal, arc, seg, innerR: currentInnerRadius, outerR });
                
                // Click handler on hit area
                hitArea.on('click', function(event) {
                    event.stopPropagation();
                    openRoseModal(m.label, seg.key, seg.data.apps);
                });
                
                // Hover effects on hit area (scales the petal)
                hitArea
                    .on('mouseenter', function() {
                        // Bring parent group to front
                        petalGroup.node().parentNode.appendChild(petalGroup.node());
                        
                        // Bring this segment group to front
                        segGroup.node().parentNode.appendChild(segGroup.node());
                        
                        // Scale the visual petal with glow
                        petal.transition()
                            .duration(200)
                            .attr('opacity', 1)
                            .attr('filter', 'url(#roseGlow)')
                            .attr('transform', 'scale(1.15)');
                        
                        // Hide label on hover (it's shown in tooltip)
                        labelText.transition()
                            .duration(150)
                            .attr('opacity', 0);
                    })
                    .on('mouseleave', function() {
                        petal.transition()
                            .duration(200)
                            .attr('opacity', 0.9)
                            .attr('filter', null)
                            .attr('transform', 'scale(1)');
                        
                        // Show label again
                        labelText.transition()
                            .duration(150)
                            .attr('opacity', 1);
                    });
                
                // Tooltip on hit area
                const riskLabel = seg.key === 'med' ? 'Medium' : 'High';
                attachTooltipHandlers(hitArea.node(), `${m.label}: ${seg.data.count} app${seg.data.count > 1 ? 's' : ''} (${riskLabel})`);
                
                currentInnerRadius = outerR + 1;
            });
        });

    }

    // Retention Widget - shows apps with 5+ years data retention
    let retentionApps = [];
    
    function renderRetentionWidget() {
        const bigText = document.getElementById('retentionBigText');
        const subText = document.getElementById('retentionSubText');
        const appIcon = document.getElementById('retentionAppIcon');
        const widget = document.getElementById('widgetRetention');
        
        if (!bigText || !subText || !widget) return;
        
        retentionApps = [];
        let maxYears = 0;
        let maxApp = null;
        
        selectedApps.forEach((appData, appId) => {
            const privacy = appData.privacy;
            if (!privacy) return;
            
            const retention = privacy.DataRetention?.overall_policy;
            if (retention) {
                // Check MaximumPeriodYears
                const maxPeriod = retention.maximum_period_years?.value;
                if (maxPeriod && !isNaN(parseFloat(maxPeriod))) {
                    const years = parseFloat(maxPeriod);
                    if (years >= 5) {
                        retentionApps.push({ appId, appData, years });
                    }
                    if (years > maxYears) {
                        maxYears = years;
                        maxApp = appData;
                    }
                }
            }
        });
        
        // Clear icon
        if (appIcon) appIcon.innerHTML = '';
        
        if (selectedApps.size === 0) {
            bigText.textContent = '—';
            subText.textContent = 'Add apps to analyze';
            return;
        }
        
        if (retentionApps.length === 0) {
            bigText.textContent = '✓';
            bigText.style.color = 'var(--chip-low)';
            subText.textContent = 'No apps retain data 5+ years';
        } else {
            // Show icon of app with max retention
            if (appIcon && maxApp && maxApp.logo_url) {
                appIcon.innerHTML = `<img src="${maxApp.logo_url}" alt="${escapeHtml(maxApp.name || '')}">`;
            }
            
            bigText.textContent = `${Math.round(maxYears)} years`;
            bigText.style.color = 'var(--chip-high)';
            subText.textContent = `${retentionApps.length} app${retentionApps.length > 1 ? 's' : ''} retain your data 5+ years`;
        }
        
        // Add click handler
        widget.onclick = () => {
            if (retentionApps.length > 0) {
                openStatModal('Data Retention', `${retentionApps.length} apps retain your data for 5+ years`, '⏰', 'var(--chip-high)', retentionApps.map(a => ({
                    appId: a.appId,
                    appData: a.appData,
                    detail: `${a.years} years`
                })));
            }
        };
    }

    // AI Training Widget - shows apps that use data for AI training
    let aiTrainingApps = [];
    
    function renderAITrainingWidget() {
        const bigText = document.getElementById('aiTrainingBigText');
        const subText = document.getElementById('aiTrainingSubText');
        const widget = document.getElementById('widgetAITraining');
        
        if (!bigText || !subText || !widget) return;
        
        aiTrainingApps = [];
        
        selectedApps.forEach((appData, appId) => {
            const privacy = appData.privacy;
            if (!privacy) return;
            
            const useAI = privacy.UseToTrainAI;
            if (useAI && useAI.used_for_training) {
                const val = String(useAI.used_for_training.value || '').toLowerCase().trim();
                if (['true', 'yes', 'present'].includes(val)) {
                    // Check if user can opt-out
                    let canOptOut = false;
                    if (useAI.user_opt_out) {
                        const rawVal = useAI.user_opt_out.value;
                        // Handle boolean true directly
                        if (rawVal === true) {
                            canOptOut = true;
                        } else if (rawVal !== undefined && rawVal !== null) {
                            const optOutVal = String(rawVal).toLowerCase().trim();
                            canOptOut = ['true', 'yes', 'present', 'partial'].includes(optOutVal);
                        }
                    }
                    aiTrainingApps.push({ appId, appData, canOptOut });
                }
            }
        });
        
        if (selectedApps.size === 0) {
            bigText.textContent = '—';
            subText.textContent = 'Add apps to analyze';
            return;
        }
        
        if (aiTrainingApps.length === 0) {
            bigText.textContent = '0 apps';
            bigText.style.color = 'var(--chip-low)';
            subText.textContent = 'use your data to train AI';
        } else {
            bigText.textContent = `${aiTrainingApps.length} app${aiTrainingApps.length > 1 ? 's' : ''}`;
            bigText.style.color = 'var(--chip-high)';
            subText.textContent = 'use your data to train AI';
        }
        
        // Add click handler
        widget.onclick = () => {
            if (aiTrainingApps.length > 0) {
                openStatModal('AI Training', `${aiTrainingApps.length} apps use your data to train AI`, '🤖', 'var(--chip-high)', aiTrainingApps.map(a => ({
                    appId: a.appId,
                    appData: a.appData,
                    detail: a.canOptOut ? '✅ You can opt out of AI training' : '❌ No opt-out available'
                })));
            }
        };
    }

    // Generic stat modal
    function openStatModal(title, subtitle, icon, iconColor, apps) {
        // Reuse rose modal structure
        roseModalTitle.textContent = title;
        roseModalSubtitle.textContent = subtitle;
        roseModalIcon.innerHTML = icon;
        roseModalIcon.style.background = iconColor;
        
        roseModalApps.innerHTML = '';
        
        apps.forEach(({ appId, appData, detail }) => {
            const item = document.createElement('div');
            item.className = 'rose-modal-app';
            
            const iconUrl = appData.logo_url;
            const appName = appData.name || appId;
            
            item.innerHTML = `
                <div class="rose-modal-app-icon">
                    ${iconUrl ? `<img src="${iconUrl}" alt="">` : '<span style="font-size:20px;opacity:.6;">📱</span>'}
                </div>
                <div class="rose-modal-app-info">
                    <div class="rose-modal-app-name">${escapeHtml(appName)}</div>
                    <div class="rose-modal-app-score">${escapeHtml(detail)}</div>
                </div>
                <div class="rose-modal-app-arrow">→</div>
            `;
            
            item.addEventListener('click', () => {
                closeRoseModal();
                switchTopView('myapps');
                selectApp(appId);
            });
            
            roseModalApps.appendChild(item);
        });
        
        roseModalOverlay.classList.add('active');
    }

    // Update dashboard when apps change
    const originalAddAppToList = addAppToList;
    addAppToList = async function(appId, appData) {
        await originalAddAppToList(appId, appData);
        if (currentTopView === 'dashboard') {
            renderDashboardWidgets();
        }
    };

    const originalRemoveAppFromList = removeAppFromList;
    removeAppFromList = function(appId) {
        originalRemoveAppFromList(appId);
        if (currentTopView === 'dashboard') {
            renderDashboardWidgets();
        }
    };

    // Initial render on auth
    const originalOnAuthCallback = onAuthStateChanged;
    // Re-render dashboard when we first load if on dashboard view
    setTimeout(() => {
        if (currentTopView === 'dashboard') {
            renderDashboardWidgets();
        }
    }, 500);

    // Resize observer for responsive widgets
    let resizeTimeout = null;
    const dashboardResizeObserver = new ResizeObserver(() => {
        if (resizeTimeout) clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            if (currentTopView === 'dashboard') {
                renderCirclePackingWidget();
                renderRoseHistogramWidget();
            }
        }, 150);
    });

    const circlePackingContainer = document.querySelector('#widgetCirclePacking .widget-content');
    if (circlePackingContainer) {
        dashboardResizeObserver.observe(circlePackingContainer);
    }
    
    const roseHistogramContainer = document.querySelector('#widgetRoseHistogram .widget-content');
    if (roseHistogramContainer) {
        dashboardResizeObserver.observe(roseHistogramContainer);
    }

    /* ===== Keyboard Shortcuts ===== */
    document.addEventListener('keydown', (e) => {
        // Don't trigger shortcuts when typing in inputs
        const activeEl = document.activeElement;
        const isTyping = activeEl && (
            activeEl.tagName === 'INPUT' || 
            activeEl.tagName === 'TEXTAREA' || 
            activeEl.isContentEditable
        );
        
        // "/" to focus search (when not typing)
        if (e.key === '/' && !isTyping) {
            e.preventDefault();
            searchInput.focus();
        }
        
        // "Escape" to close modals/overlays or blur search
        if (e.key === 'Escape') {
            // Close settings modal
            if (settingsModalOverlay && settingsModalOverlay.classList.contains('active')) {
                closeSettingsModal();
                return;
            }
            
            // Close video import overlay
            if (videoImportOverlay.classList.contains('active')) {
                videoImportOverlay.classList.remove('active');
                videoInput.value = '';
                videoImportProgress.classList.remove('active');
                resetVideoImportState();
                return;
            }
            
            // Close category modal
            const categoryModalOverlay = document.getElementById('categoryModalOverlay');
            if (categoryModalOverlay && categoryModalOverlay.classList.contains('active')) {
                categoryModalOverlay.classList.remove('active');
                return;
            }
            
            // Close rose modal
            if (roseModalOverlay && roseModalOverlay.classList.contains('active')) {
                roseModalOverlay.classList.remove('active');
                return;
            }
            
            // Close suggestions and blur search
            if (suggestions.style.display === 'block') {
                suggestions.style.display = 'none';
                searchInput.blur();
                return;
            }
            
            // Blur search if focused
            if (document.activeElement === searchInput) {
                searchInput.blur();
            }
        }
        
        // "1" or "2" to switch between Dashboard/My Apps (when not typing)
        if (!isTyping && (e.key === '1' || e.key === '2')) {
            const view = e.key === '1' ? 'dashboard' : 'myapps';
            switchTopView(view);
        }
    });
    
    // Show welcome toast on first load (only once per session)
    if (!sessionStorage.getItem('welcomeShown')) {
        setTimeout(() => {
            toastInfo('Press "/" to search, "Esc" to close modals, "1"/"2" to switch views.', 'Keyboard Shortcuts');
            sessionStorage.setItem('welcomeShown', 'true');
        }, 1500);
    }

</script>
</body>
</html>
